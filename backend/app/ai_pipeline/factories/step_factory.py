# backend/app/ai_pipeline/factories/step_factory.py
"""
üî• StepFactory v5.0 - ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ Ìå®ÌÑ¥ + ÏàúÌôòÏ∞∏Ï°∞ ÏôÑÏ†Ñ Ìï¥Í≤∞
==============================================================

‚úÖ TYPE_CHECKING Ìå®ÌÑ¥ÏúºÎ°ú ÏàúÌôòÏ∞∏Ï°∞ ÏôÑÏ†Ñ Î∞©ÏßÄ
‚úÖ ÌÜµÌï©Îêú ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ ÏãúÏä§ÌÖú
‚úÖ ÌëúÏ§ÄÌôîÎêú Step ÏÉùÏÑ± Ìå®ÌÑ¥
‚úÖ Î™®Îì† Step ÌÅ¥ÎûòÏä§ Ìò∏ÌôòÏÑ± Î≥¥Ïû•
‚úÖ Ìñ•ÏÉÅÎêú ÏóêÎü¨ Ï≤òÎ¶¨

Author: MyCloset AI Team
Date: 2025-07-24
Version: 5.0 (Dependency Injection Pattern)
"""

import os
import logging
import asyncio
import threading
import time
import weakref
from pathlib import Path
from typing import Dict, Any, Optional, List, Union, Type, Callable, TYPE_CHECKING
from dataclasses import dataclass, field
from enum import Enum, IntEnum
from abc import ABC, abstractmethod

# üî• TYPE_CHECKINGÏúºÎ°ú ÏàúÌôòÏ∞∏Ï°∞ ÏôÑÏ†Ñ Î∞©ÏßÄ
if TYPE_CHECKING:
    from ..steps.base_step_mixin import BaseStepMixin
    from ..utils.model_loader import ModelLoader
    from ..utils.memory_manager import MemoryManager
    from ..utils.data_converter import DataConverter
    from ..core.di_container import DIContainer

# ==============================================
# üî• Í∏∞Î≥∏ ÏÑ§Ï†ï Î∞è Î°úÍπÖ
# ==============================================

logger = logging.getLogger(__name__)

# ÌôòÍ≤Ω Ï†ïÎ≥¥
CONDA_ENV = os.environ.get('CONDA_DEFAULT_ENV', 'none')
IS_M3_MAX = False

try:
    import platform
    import subprocess
    if platform.system() == 'Darwin':
        result = subprocess.run(
            ['sysctl', '-n', 'machdep.cpu.brand_string'],
            capture_output=True, text=True, timeout=5
        )
        IS_M3_MAX = 'M3' in result.stdout
except:
    pass

# ==============================================
# üî• Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ Ï†ïÏùò
# ==============================================

class StepType(Enum):
    """Step ÌÉÄÏûÖ Ï†ïÏùò"""
    HUMAN_PARSING = "human_parsing"
    POSE_ESTIMATION = "pose_estimation"
    CLOTH_SEGMENTATION = "cloth_segmentation"
    GEOMETRIC_MATCHING = "geometric_matching"
    CLOTH_WARPING = "cloth_warping"
    VIRTUAL_FITTING = "virtual_fitting"
    POST_PROCESSING = "post_processing"
    QUALITY_ASSESSMENT = "quality_assessment"

class StepPriority(IntEnum):
    """Step Ïö∞ÏÑ†ÏàúÏúÑ"""
    CRITICAL = 1
    HIGH = 2
    MEDIUM = 3
    LOW = 4

@dataclass
class StepConfig:
    """Step ÏÑ§Ï†ï"""
    step_name: str
    step_id: int
    step_type: StepType
    device: str = "auto"
    use_fp16: bool = True
    batch_size: int = 1
    confidence_threshold: float = 0.8
    auto_memory_cleanup: bool = True
    auto_warmup: bool = True
    optimization_enabled: bool = True
    strict_mode: bool = False
    priority: StepPriority = StepPriority.MEDIUM
    
    # ÏùòÏ°¥ÏÑ± ÏÑ§Ï†ï
    require_model_loader: bool = True
    require_memory_manager: bool = False
    require_data_converter: bool = False
    auto_inject_dependencies: bool = True

@dataclass
class StepCreationResult:
    """Step ÏÉùÏÑ± Í≤∞Í≥º"""
    success: bool
    step_instance: Optional['BaseStepMixin'] = None
    step_name: str = ""
    step_type: Optional[StepType] = None
    dependencies_injected: Dict[str, bool] = field(default_factory=dict)
    initialization_time: float = 0.0
    error_message: Optional[str] = None
    warnings: List[str] = field(default_factory=list)

@dataclass
class DependencyBundle:
    """ÏùòÏ°¥ÏÑ± Î≤àÎì§"""
    model_loader: Optional['ModelLoader'] = None
    memory_manager: Optional['MemoryManager'] = None
    data_converter: Optional['DataConverter'] = None
    di_container: Optional['DIContainer'] = None

# ==============================================
# üî• ÏùòÏ°¥ÏÑ± Ìï¥Í≤∞Í∏∞
# ==============================================

class DependencyResolver:
    """ÏùòÏ°¥ÏÑ± Ìï¥Í≤∞Í∏∞ (ÏàúÌôòÏ∞∏Ï°∞ Î∞©ÏßÄ)"""
    
    def __init__(self):
        self.logger = logging.getLogger("DependencyResolver")
        self._resolved_cache: Dict[str, Any] = {}
        self._resolution_lock = threading.Lock()
    
    def resolve_model_loader(self, config: Optional[Dict[str, Any]] = None) -> Optional['ModelLoader']:
        """ModelLoader Ìï¥Í≤∞ (ÎèôÏ†Å import)"""
        try:
            with self._resolution_lock:
                cache_key = "model_loader"
                if cache_key in self._resolved_cache:
                    return self._resolved_cache[cache_key]
                
                # ÎèôÏ†Å importÎ°ú ÏàúÌôòÏ∞∏Ï°∞ Î∞©ÏßÄ
                import importlib
                model_loader_module = importlib.import_module('app.ai_pipeline.utils.model_loader')
                get_global_loader = getattr(model_loader_module, 'get_global_model_loader', None)
                
                if get_global_loader:
                    model_loader = get_global_loader(config)
                    # Ï¥àÍ∏∞Ìôî ÌôïÏù∏
                    if hasattr(model_loader, 'initialize'):
                        if not model_loader.is_initialized():
                            success = model_loader.initialize()
                            if not success:
                                self.logger.error("ModelLoader Ï¥àÍ∏∞Ìôî Ïã§Ìå®")
                                return None
                    
                    self._resolved_cache[cache_key] = model_loader
                    self.logger.info("‚úÖ ModelLoader Ìï¥Í≤∞ ÏôÑÎ£å")
                    return model_loader
                else:
                    self.logger.error("get_global_model_loader Ìï®ÏàòÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå")
                    return None
                    
        except Exception as e:
            self.logger.error(f"‚ùå ModelLoader Ìï¥Í≤∞ Ïã§Ìå®: {e}")
            return None
    
    def resolve_memory_manager(self) -> Optional['MemoryManager']:
        """MemoryManager Ìï¥Í≤∞ (ÎèôÏ†Å import)"""
        try:
            with self._resolution_lock:
                cache_key = "memory_manager"
                if cache_key in self._resolved_cache:
                    return self._resolved_cache[cache_key]
                
                import importlib
                memory_module = importlib.import_module('app.ai_pipeline.utils.memory_manager')
                get_global_manager = getattr(memory_module, 'get_global_memory_manager', None)
                
                if get_global_manager:
                    memory_manager = get_global_manager()
                    self._resolved_cache[cache_key] = memory_manager
                    self.logger.info("‚úÖ MemoryManager Ìï¥Í≤∞ ÏôÑÎ£å")
                    return memory_manager
                    
        except Exception as e:
            self.logger.debug(f"MemoryManager Ìï¥Í≤∞ Ïã§Ìå®: {e}")
            return None
    
    def resolve_data_converter(self) -> Optional['DataConverter']:
        """DataConverter Ìï¥Í≤∞ (ÎèôÏ†Å import)"""
        try:
            with self._resolution_lock:
                cache_key = "data_converter"
                if cache_key in self._resolved_cache:
                    return self._resolved_cache[cache_key]
                
                import importlib
                converter_module = importlib.import_module('app.ai_pipeline.utils.data_converter')
                get_global_converter = getattr(converter_module, 'get_global_data_converter', None)
                
                if get_global_converter:
                    data_converter = get_global_converter()
                    self._resolved_cache[cache_key] = data_converter
                    self.logger.info("‚úÖ DataConverter Ìï¥Í≤∞ ÏôÑÎ£å")
                    return data_converter
                    
        except Exception as e:
            self.logger.debug(f"DataConverter Ìï¥Í≤∞ Ïã§Ìå®: {e}")
            return None
    
    def resolve_di_container(self) -> Optional['DIContainer']:
        """DI Container Ìï¥Í≤∞ (ÎèôÏ†Å import)"""
        try:
            with self._resolution_lock:
                cache_key = "di_container"
                if cache_key in self._resolved_cache:
                    return self._resolved_cache[cache_key]
                
                import importlib
                di_module = importlib.import_module('app.core.di_container')
                get_global_container = getattr(di_module, 'get_global_di_container', None)
                
                if get_global_container:
                    di_container = get_global_container()
                    self._resolved_cache[cache_key] = di_container
                    self.logger.info("‚úÖ DI Container Ìï¥Í≤∞ ÏôÑÎ£å")
                    return di_container
                    
        except Exception as e:
            self.logger.debug(f"DI Container Ìï¥Í≤∞ Ïã§Ìå®: {e}")
            return None
    
    def resolve_step_mixin_class(self, step_type: StepType) -> Optional[Type]:
        """BaseStepMixin ÌÅ¥ÎûòÏä§ Ìï¥Í≤∞ (ÎèôÏ†Å import)"""
        try:
            cache_key = f"step_mixin_{step_type.value}"
            if cache_key in self._resolved_cache:
                return self._resolved_cache[cache_key]
            
            import importlib
            mixin_module = importlib.import_module('app.ai_pipeline.steps.base_step_mixin')
            
            # Step ÌÉÄÏûÖÎ≥Ñ ÌÅ¥ÎûòÏä§ Îß§Ìïë
            class_mapping = {
                StepType.HUMAN_PARSING: 'HumanParsingMixin',
                StepType.POSE_ESTIMATION: 'PoseEstimationMixin',
                StepType.CLOTH_SEGMENTATION: 'ClothSegmentationMixin',
                StepType.GEOMETRIC_MATCHING: 'GeometricMatchingMixin',
                StepType.CLOTH_WARPING: 'ClothWarpingMixin',
                StepType.VIRTUAL_FITTING: 'VirtualFittingMixin',
                StepType.POST_PROCESSING: 'PostProcessingMixin',
                StepType.QUALITY_ASSESSMENT: 'QualityAssessmentMixin'
            }
            
            class_name = class_mapping.get(step_type, 'BaseStepMixin')
            StepClass = getattr(mixin_module, class_name, None)
            
            if not StepClass:
                self.logger.error(f"{class_name} ÌÅ¥ÎûòÏä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå")
                return None
            
            self._resolved_cache[cache_key] = StepClass
            self.logger.info(f"‚úÖ {class_name} ÌÅ¥ÎûòÏä§ Ìï¥Í≤∞ ÏôÑÎ£å")
            return StepClass
            
        except Exception as e:
            self.logger.error(f"‚ùå Step ÌÅ¥ÎûòÏä§ Ìï¥Í≤∞ Ïã§Ìå®: {e}")
            return None
    
    def create_dependency_bundle(self, config: StepConfig) -> DependencyBundle:
        """ÏùòÏ°¥ÏÑ± Î≤àÎì§ ÏÉùÏÑ±"""
        try:
            bundle = DependencyBundle()
            
            # ÌïÑÏàò ÏùòÏ°¥ÏÑ±Î∂ÄÌÑ∞ Ìï¥Í≤∞
            if config.require_model_loader:
                bundle.model_loader = self.resolve_model_loader()
            
            if config.require_memory_manager:
                bundle.memory_manager = self.resolve_memory_manager()
            
            if config.require_data_converter:
                bundle.data_converter = self.resolve_data_converter()
            
            # DI ContainerÎäî Ìï≠ÏÉÅ ÏãúÎèÑ
            bundle.di_container = self.resolve_di_container()
            
            return bundle
            
        except Exception as e:
            self.logger.error(f"‚ùå ÏùòÏ°¥ÏÑ± Î≤àÎì§ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return DependencyBundle()
    
    def clear_cache(self):
        """Ï∫êÏãú Ï†ïÎ¶¨"""
        with self._resolution_lock:
            self._resolved_cache.clear()
            self.logger.info("üßπ ÏùòÏ°¥ÏÑ± Ìï¥Í≤∞Í∏∞ Ï∫êÏãú Ï†ïÎ¶¨ ÏôÑÎ£å")

# ==============================================
# üî• Î©îÏù∏ StepFactory ÌÅ¥ÎûòÏä§
# ==============================================

class StepFactory:
    """ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ Ìå®ÌÑ¥ StepFactory v5.0"""
    
    def __init__(self):
        self.logger = logging.getLogger("StepFactory")
        
        # ÏùòÏ°¥ÏÑ± Ìï¥Í≤∞Í∏∞
        self.dependency_resolver = DependencyResolver()
        
        # Ï∫êÏãú Î∞è ÏÉÅÌÉú Í¥ÄÎ¶¨
        self._step_cache: Dict[str, weakref.ref] = {}
        self._creation_stats = {
            'total_created': 0,
            'successful_creations': 0,
            'failed_creations': 0,
            'cache_hits': 0,
            'dependencies_resolved': 0
        }
        
        # ÎèôÍ∏∞Ìôî
        self._lock = threading.RLock()
        
        self.logger.info("üè≠ StepFactory v5.0 Ï¥àÍ∏∞Ìôî ÏôÑÎ£å (ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ Ìå®ÌÑ¥)")
    
    def create_step(
        self, 
        step_type: Union[StepType, str], 
        config: Optional[StepConfig] = None,
        use_cache: bool = True,
        **kwargs
    ) -> StepCreationResult:
        """ÌÜµÌï© Step ÏÉùÏÑ± Î©îÏÑúÎìú"""
        start_time = time.time()
        
        try:
            # Step ÌÉÄÏûÖ Ï†ïÍ∑úÌôî
            if isinstance(step_type, str):
                try:
                    step_type = StepType(step_type.lower())
                except ValueError:
                    return StepCreationResult(
                        success=False,
                        error_message=f"ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Step ÌÉÄÏûÖ: {step_type}"
                    )
            
            # ÏÑ§Ï†ï ÏÉùÏÑ±
            if config is None:
                config = self._create_default_config(step_type, **kwargs)
            
            # Ï∫êÏãú ÌôïÏù∏
            if use_cache:
                cached_step = self._get_cached_step(config.step_name)
                if cached_step:
                    self._creation_stats['cache_hits'] += 1
                    return StepCreationResult(
                        success=True,
                        step_instance=cached_step,
                        step_name=config.step_name,
                        step_type=step_type,
                        initialization_time=time.time() - start_time
                    )
            
            # Step ÏÉùÏÑ± Ïã§Ìñâ
            result = self._create_step_instance(step_type, config)
            
            # ÏÑ±Í≥µ Ïãú Ï∫êÏãúÏóê Ï†ÄÏû•
            if result.success and result.step_instance and use_cache:
                self._cache_step(config.step_name, result.step_instance)
            
            # ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            self._creation_stats['total_created'] += 1
            if result.success:
                self._creation_stats['successful_creations'] += 1
            else:
                self._creation_stats['failed_creations'] += 1
            
            result.initialization_time = time.time() - start_time
            
            return result
            
        except Exception as e:
            self.logger.error(f"‚ùå Step ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return StepCreationResult(
                success=False,
                error_message=f"Step ÏÉùÏÑ± Ï§ë ÏòàÏô∏ Î∞úÏÉù: {str(e)}",
                initialization_time=time.time() - start_time
            )
    
    def _create_default_config(self, step_type: StepType, **kwargs) -> StepConfig:
        """Í∏∞Î≥∏ ÏÑ§Ï†ï ÏÉùÏÑ±"""
        # StepÎ≥Ñ Í∏∞Î≥∏ ÏÑ§Ï†ï
        step_configs = {
            StepType.HUMAN_PARSING: {
                'step_name': 'HumanParsingStep',
                'step_id': 1,
                'priority': StepPriority.CRITICAL
            },
            StepType.POSE_ESTIMATION: {
                'step_name': 'PoseEstimationStep',
                'step_id': 2,
                'priority': StepPriority.HIGH
            },
            StepType.CLOTH_SEGMENTATION: {
                'step_name': 'ClothSegmentationStep',
                'step_id': 3,
                'priority': StepPriority.HIGH
            },
            StepType.GEOMETRIC_MATCHING: {
                'step_name': 'GeometricMatchingStep',
                'step_id': 4,
                'priority': StepPriority.MEDIUM
            },
            StepType.CLOTH_WARPING: {
                'step_name': 'ClothWarpingStep',
                'step_id': 5,
                'priority': StepPriority.MEDIUM
            },
            StepType.VIRTUAL_FITTING: {
                'step_name': 'VirtualFittingStep',
                'step_id': 6,
                'priority': StepPriority.CRITICAL
            },
            StepType.POST_PROCESSING: {
                'step_name': 'PostProcessingStep',
                'step_id': 7,
                'priority': StepPriority.LOW
            },
            StepType.QUALITY_ASSESSMENT: {
                'step_name': 'QualityAssessmentStep',
                'step_id': 8,
                'priority': StepPriority.LOW
            }
        }
        
        default_config = step_configs.get(step_type, {
            'step_name': f'{step_type.value.title()}Step',
            'step_id': 0,
            'priority': StepPriority.MEDIUM
        })
        
        # kwargsÎ°ú ÎçÆÏñ¥Ïì∞Í∏∞
        default_config.update(kwargs)
        
        return StepConfig(
            step_type=step_type,
            **default_config
        )
    
    def _create_step_instance(self, step_type: StepType, config: StepConfig) -> StepCreationResult:
        """Step Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±"""
        try:
            self.logger.info(f"üîÑ {config.step_name} ÏÉùÏÑ± ÏãúÏûë...")
            
            # 1. Step ÌÅ¥ÎûòÏä§ Ìï¥Í≤∞
            StepClass = self.dependency_resolver.resolve_step_mixin_class(step_type)
            if not StepClass:
                return StepCreationResult(
                    success=False,
                    step_name=config.step_name,
                    step_type=step_type,
                    error_message=f"{step_type.value} Step ÌÅ¥ÎûòÏä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå"
                )
            
            # 2. ÏùòÏ°¥ÏÑ± Î≤àÎì§ ÏÉùÏÑ±
            dependency_bundle = self.dependency_resolver.create_dependency_bundle(config)
            
            # 3. Step Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
            step_kwargs = {
                'step_name': config.step_name,
                'step_id': config.step_id,
                'device': config.device,
                'use_fp16': config.use_fp16,
                'batch_size': config.batch_size,
                'confidence_threshold': config.confidence_threshold,
                'auto_memory_cleanup': config.auto_memory_cleanup,
                'auto_warmup': config.auto_warmup,
                'optimization_enabled': config.optimization_enabled,
                'strict_mode': config.strict_mode,
                'auto_inject_dependencies': config.auto_inject_dependencies,
                'require_model_loader': config.require_model_loader,
                'require_memory_manager': config.require_memory_manager,
                'require_data_converter': config.require_data_converter
            }
            
            step_instance = StepClass(**step_kwargs)
            
            # 4. ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ
            dependencies_injected = self._inject_dependencies(step_instance, dependency_bundle, config)
            
            # 5. Ï¥àÍ∏∞Ìôî Ïã§Ìñâ
            initialization_success = self._initialize_step(step_instance, config)
            
            if not initialization_success and config.strict_mode:
                return StepCreationResult(
                    success=False,
                    step_name=config.step_name,
                    step_type=step_type,
                    error_message="Step Ï¥àÍ∏∞Ìôî Ïã§Ìå® (Strict Mode)",
                    dependencies_injected=dependencies_injected
                )
            
            self.logger.info(f"‚úÖ {config.step_name} ÏÉùÏÑ± ÏôÑÎ£å")
            
            return StepCreationResult(
                success=True,
                step_instance=step_instance,
                step_name=config.step_name,
                step_type=step_type,
                dependencies_injected=dependencies_injected
            )
            
        except Exception as e:
            self.logger.error(f"‚ùå {config.step_name} ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return StepCreationResult(
                success=False,
                step_name=config.step_name,
                step_type=step_type,
                error_message=f"Step Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Ïã§Ìå®: {str(e)}"
            )
    
    def _inject_dependencies(
        self, 
        step_instance: 'BaseStepMixin', 
        dependency_bundle: DependencyBundle,
        config: StepConfig
    ) -> Dict[str, bool]:
        """ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ Ïã§Ìñâ"""
        injection_results = {}
        
        try:
            # ModelLoader Ï£ºÏûÖ
            if dependency_bundle.model_loader and hasattr(step_instance, 'set_model_loader'):
                try:
                    step_instance.set_model_loader(dependency_bundle.model_loader)
                    injection_results['model_loader'] = True
                    self._creation_stats['dependencies_resolved'] += 1
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è ModelLoader Ï£ºÏûÖ Ïã§Ìå®: {e}")
                    injection_results['model_loader'] = False
            else:
                injection_results['model_loader'] = False
            
            # MemoryManager Ï£ºÏûÖ
            if dependency_bundle.memory_manager and hasattr(step_instance, 'set_memory_manager'):
                try:
                    step_instance.set_memory_manager(dependency_bundle.memory_manager)
                    injection_results['memory_manager'] = True
                    self._creation_stats['dependencies_resolved'] += 1
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è MemoryManager Ï£ºÏûÖ Ïã§Ìå®: {e}")
                    injection_results['memory_manager'] = False
            else:
                injection_results['memory_manager'] = False
            
            # DataConverter Ï£ºÏûÖ
            if dependency_bundle.data_converter and hasattr(step_instance, 'set_data_converter'):
                try:
                    step_instance.set_data_converter(dependency_bundle.data_converter)
                    injection_results['data_converter'] = True
                    self._creation_stats['dependencies_resolved'] += 1
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è DataConverter Ï£ºÏûÖ Ïã§Ìå®: {e}")
                    injection_results['data_converter'] = False
            else:
                injection_results['data_converter'] = False
            
            # DI Container Ï£ºÏûÖ
            if dependency_bundle.di_container and hasattr(step_instance, 'set_di_container'):
                try:
                    step_instance.set_di_container(dependency_bundle.di_container)
                    injection_results['di_container'] = True
                    self._creation_stats['dependencies_resolved'] += 1
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è DI Container Ï£ºÏûÖ Ïã§Ìå®: {e}")
                    injection_results['di_container'] = False
            else:
                injection_results['di_container'] = False
            
            # ÌïÑÏàò ÏùòÏ°¥ÏÑ± Í≤ÄÏ¶ù
            required_dependencies = []
            if config.require_model_loader:
                required_dependencies.append('model_loader')
            if config.require_memory_manager:
                required_dependencies.append('memory_manager')
            if config.require_data_converter:
                required_dependencies.append('data_converter')
            
            missing_dependencies = [
                dep for dep in required_dependencies 
                if not injection_results.get(dep, False)
            ]
            
            if missing_dependencies and config.strict_mode:
                self.logger.error(f"‚ùå ÌïÑÏàò ÏùòÏ°¥ÏÑ± ÎàÑÎùΩ: {missing_dependencies}")
                raise RuntimeError(f"ÌïÑÏàò ÏùòÏ°¥ÏÑ±Ïù¥ Ï£ºÏûÖÎêòÏßÄ ÏïäÏùå: {missing_dependencies}")
            
            success_count = sum(1 for success in injection_results.values() if success)
            self.logger.info(f"üíâ ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ ÏôÑÎ£å: {success_count}/{len(injection_results)} ÏÑ±Í≥µ")
            
            return injection_results
            
        except Exception as e:
            self.logger.error(f"‚ùå ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ Ïã§Ìå®: {e}")
            return injection_results
    
    def _initialize_step(self, step_instance: 'BaseStepMixin', config: StepConfig) -> bool:
        """Step Ï¥àÍ∏∞Ìôî Ïã§Ìñâ"""
        try:
            # BaseStepMixin Ï¥àÍ∏∞Ìôî
            if hasattr(step_instance, 'initialize'):
                success = step_instance.initialize()
                if not success:
                    self.logger.error(f"‚ùå {config.step_name} Ï¥àÍ∏∞Ìôî Ïã§Ìå®")
                    return False
            
            # ÏõåÎ∞çÏóÖ Ïã§Ìñâ (ÏÑ§Ï†ïÎêú Í≤ΩÏö∞)
            if config.auto_warmup and hasattr(step_instance, 'warmup'):
                try:
                    warmup_result = step_instance.warmup()
                    if warmup_result.get('success', False):
                        self.logger.info(f"üî• {config.step_name} ÏõåÎ∞çÏóÖ ÏôÑÎ£å")
                    else:
                        self.logger.warning(f"‚ö†Ô∏è {config.step_name} ÏõåÎ∞çÏóÖ Ïã§Ìå®")
                except Exception as warmup_error:
                    self.logger.warning(f"‚ö†Ô∏è {config.step_name} ÏõåÎ∞çÏóÖ Ïò§Î•ò: {warmup_error}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå {config.step_name} Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
            return False
    
    def _get_cached_step(self, step_name: str) -> Optional['BaseStepMixin']:
        """Ï∫êÏãúÎêú Step Ï°∞Ìöå"""
        try:
            with self._lock:
                if step_name in self._step_cache:
                    weak_ref = self._step_cache[step_name]
                    step_instance = weak_ref()
                    if step_instance is not None:
                        self.logger.debug(f"‚ôªÔ∏è Ï∫êÏãúÎêú Step Î∞òÌôò: {step_name}")
                        return step_instance
                    else:
                        # ÏïΩÌïú Ï∞∏Ï°∞Í∞Ä Ìï¥Ï†úÎê®
                        del self._step_cache[step_name]
                return None
        except Exception as e:
            self.logger.debug(f"Ï∫êÏãú Ï°∞Ìöå Ïã§Ìå®: {e}")
            return None
    
    def _cache_step(self, step_name: str, step_instance: 'BaseStepMixin'):
        """Step Ï∫êÏãúÏóê Ï†ÄÏû•"""
        try:
            with self._lock:
                self._step_cache[step_name] = weakref.ref(step_instance)
                self.logger.debug(f"üíæ Step Ï∫êÏãúÏóê Ï†ÄÏû•: {step_name}")
        except Exception as e:
            self.logger.debug(f"Ï∫êÏãú Ï†ÄÏû• Ïã§Ìå®: {e}")
    
    # ==============================================
    # üî• ÎπÑÎèôÍ∏∞ Step ÏÉùÏÑ±
    # ==============================================
    
    async def create_step_async(
        self, 
        step_type: Union[StepType, str], 
        config: Optional[StepConfig] = None,
        use_cache: bool = True,
        **kwargs
    ) -> StepCreationResult:
        """ÎπÑÎèôÍ∏∞ Step ÏÉùÏÑ±"""
        try:
            # ÎèôÍ∏∞ ÏÉùÏÑ±ÏùÑ executorÏóêÏÑú Ïã§Ìñâ
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.create_step,
                step_type,
                config,
                use_cache,
                **kwargs
            )
            
            # ÎπÑÎèôÍ∏∞ Ï¥àÍ∏∞Ìôî (Í∞ÄÎä•Ìïú Í≤ΩÏö∞)
            if result.success and result.step_instance:
                if hasattr(result.step_instance, 'initialize_async'):
                    try:
                        await result.step_instance.initialize_async()
                        self.logger.info(f"‚úÖ {result.step_name} ÎπÑÎèôÍ∏∞ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
                    except Exception as async_init_error:
                        self.logger.warning(f"‚ö†Ô∏è {result.step_name} ÎπÑÎèôÍ∏∞ Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {async_init_error}")
                        if not result.warnings:
                            result.warnings = []
                        result.warnings.append(f"ÎπÑÎèôÍ∏∞ Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {async_init_error}")
            
            return result
            
        except Exception as e:
            self.logger.error(f"‚ùå ÎπÑÎèôÍ∏∞ Step ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return StepCreationResult(
                success=False,
                error_message=f"ÎπÑÎèôÍ∏∞ Step ÏÉùÏÑ± Ïã§Ìå®: {str(e)}"
            )
    
    # ==============================================
    # üî• Ìé∏Ïùò Î©îÏÑúÎìúÎì§
    # ==============================================
    
    def create_human_parsing_step(self, **kwargs) -> StepCreationResult:
        """Human Parsing Step ÏÉùÏÑ±"""
        return self.create_step(StepType.HUMAN_PARSING, **kwargs)
    
    def create_pose_estimation_step(self, **kwargs) -> StepCreationResult:
        """Pose Estimation Step ÏÉùÏÑ±"""
        return self.create_step(StepType.POSE_ESTIMATION, **kwargs)
    
    def create_cloth_segmentation_step(self, **kwargs) -> StepCreationResult:
        """Cloth Segmentation Step ÏÉùÏÑ±"""
        return self.create_step(StepType.CLOTH_SEGMENTATION, **kwargs)
    
    def create_geometric_matching_step(self, **kwargs) -> StepCreationResult:
        """Geometric Matching Step ÏÉùÏÑ±"""
        return self.create_step(StepType.GEOMETRIC_MATCHING, **kwargs)
    
    def create_cloth_warping_step(self, **kwargs) -> StepCreationResult:
        """Cloth Warping Step ÏÉùÏÑ±"""
        return self.create_step(StepType.CLOTH_WARPING, **kwargs)
    
    def create_virtual_fitting_step(self, **kwargs) -> StepCreationResult:
        """Virtual Fitting Step ÏÉùÏÑ±"""
        return self.create_step(StepType.VIRTUAL_FITTING, **kwargs)
    
    def create_post_processing_step(self, **kwargs) -> StepCreationResult:
        """Post Processing Step ÏÉùÏÑ±"""
        return self.create_step(StepType.POST_PROCESSING, **kwargs)
    
    def create_quality_assessment_step(self, **kwargs) -> StepCreationResult:
        """Quality Assessment Step ÏÉùÏÑ±"""
        return self.create_step(StepType.QUALITY_ASSESSMENT, **kwargs)
    
    # ÎπÑÎèôÍ∏∞ Ìé∏Ïùò Î©îÏÑúÎìúÎì§
    async def create_human_parsing_step_async(self, **kwargs) -> StepCreationResult:
        """ÎπÑÎèôÍ∏∞ Human Parsing Step ÏÉùÏÑ±"""
        return await self.create_step_async(StepType.HUMAN_PARSING, **kwargs)
    
    async def create_pose_estimation_step_async(self, **kwargs) -> StepCreationResult:
        """ÎπÑÎèôÍ∏∞ Pose Estimation Step ÏÉùÏÑ±"""
        return await self.create_step_async(StepType.POSE_ESTIMATION, **kwargs)
    
    async def create_cloth_segmentation_step_async(self, **kwargs) -> StepCreationResult:
        """ÎπÑÎèôÍ∏∞ Cloth Segmentation Step ÏÉùÏÑ±"""
        return await self.create_step_async(StepType.CLOTH_SEGMENTATION, **kwargs)
    
    async def create_virtual_fitting_step_async(self, **kwargs) -> StepCreationResult:
        """ÎπÑÎèôÍ∏∞ Virtual Fitting Step ÏÉùÏÑ±"""
        return await self.create_step_async(StepType.VIRTUAL_FITTING, **kwargs)
    
    # ==============================================
    # üî• Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±
    # ==============================================
    
    def create_full_pipeline(self, device: str = "auto", **kwargs) -> Dict[str, StepCreationResult]:
        """Ï†ÑÏ≤¥ AI ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±"""
        try:
            self.logger.info("üöÄ Ï†ÑÏ≤¥ AI ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ± ÏãúÏûë...")
            
            pipeline_results = {}
            
            # Î™®Îì† Step ÌÉÄÏûÖÏóê ÎåÄÌï¥ ÏàúÏ∞®Ï†ÅÏúºÎ°ú ÏÉùÏÑ±
            for step_type in StepType:
                try:
                    config_kwargs = {
                        'device': device,
                        **kwargs
                    }
                    
                    result = self.create_step(step_type, **config_kwargs)
                    pipeline_results[step_type.value] = result
                    
                    if result.success:
                        self.logger.info(f"‚úÖ {result.step_name} ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ± ÏÑ±Í≥µ")
                    else:
                        self.logger.error(f"‚ùå {step_type.value} ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ± Ïã§Ìå®: {result.error_message}")
                        
                except Exception as step_error:
                    self.logger.error(f"‚ùå {step_type.value} Step ÏÉùÏÑ± Ï§ë ÏòàÏô∏: {step_error}")
                    pipeline_results[step_type.value] = StepCreationResult(
                        success=False,
                        step_name=f"{step_type.value}Step",
                        step_type=step_type,
                        error_message=str(step_error)
                    )
            
            success_count = sum(1 for result in pipeline_results.values() if result.success)
            total_count = len(pipeline_results)
            
            self.logger.info(f"üèÅ Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ± ÏôÑÎ£å: {success_count}/{total_count} ÏÑ±Í≥µ")
            
            return pipeline_results
            
        except Exception as e:
            self.logger.error(f"‚ùå Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return {}
    
    async def create_full_pipeline_async(self, device: str = "auto", **kwargs) -> Dict[str, StepCreationResult]:
        """ÎπÑÎèôÍ∏∞ Ï†ÑÏ≤¥ AI ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±"""
        try:
            self.logger.info("üöÄ ÎπÑÎèôÍ∏∞ Ï†ÑÏ≤¥ AI ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ± ÏãúÏûë...")
            
            # Î™®Îì† StepÏùÑ ÎèôÏãúÏóê ÏÉùÏÑ±
            tasks = []
            for step_type in StepType:
                config_kwargs = {
                    'device': device,
                    **kwargs
                }
                task = asyncio.create_task(
                    self.create_step_async(step_type, **config_kwargs)
                )
                tasks.append((step_type, task))
            
            # Î™®Îì† Task ÏôÑÎ£å ÎåÄÍ∏∞
            pipeline_results = {}
            for step_type, task in tasks:
                try:
                    result = await task
                    pipeline_results[step_type.value] = result
                    
                    if result.success:
                        self.logger.info(f"‚úÖ {result.step_name} ÎπÑÎèôÍ∏∞ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ± ÏÑ±Í≥µ")
                    else:
                        self.logger.error(f"‚ùå {step_type.value} ÎπÑÎèôÍ∏∞ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ± Ïã§Ìå®")
                        
                except Exception as step_error:
                    self.logger.error(f"‚ùå {step_type.value} ÎπÑÎèôÍ∏∞ Step ÏÉùÏÑ± Ï§ë ÏòàÏô∏: {step_error}")
                    pipeline_results[step_type.value] = StepCreationResult(
                        success=False,
                        step_name=f"{step_type.value}Step",
                        step_type=step_type,
                        error_message=str(step_error)
                    )
            
            success_count = sum(1 for result in pipeline_results.values() if result.success)
            total_count = len(pipeline_results)
            
            self.logger.info(f"üèÅ ÎπÑÎèôÍ∏∞ Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ± ÏôÑÎ£å: {success_count}/{total_count} ÏÑ±Í≥µ")
            
            return pipeline_results
            
        except Exception as e:
            self.logger.error(f"‚ùå ÎπÑÎèôÍ∏∞ Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return {}
    
    # ==============================================
    # üî• ÏÉÅÌÉú Î∞è ÌÜµÍ≥Ñ Î©îÏÑúÎìúÎì§
    # ==============================================
    
    def get_creation_statistics(self) -> Dict[str, Any]:
        """ÏÉùÏÑ± ÌÜµÍ≥Ñ Ï°∞Ìöå"""
        try:
            with self._lock:
                total = self._creation_stats['total_created']
                success_rate = (
                    self._creation_stats['successful_creations'] / max(1, total) * 100
                )
                
                return {
                    'total_created': total,
                    'successful_creations': self._creation_stats['successful_creations'],
                    'failed_creations': self._creation_stats['failed_creations'],
                    'success_rate': round(success_rate, 2),
                    'cache_hits': self._creation_stats['cache_hits'],
                    'dependencies_resolved': self._creation_stats['dependencies_resolved'],
                    'cached_steps': len(self._step_cache),
                    'active_cache_entries': len([
                        ref for ref in self._step_cache.values() 
                        if ref() is not None
                    ])
                }
        except Exception as e:
            self.logger.error(f"‚ùå ÌÜµÍ≥Ñ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return {}
    
    def clear_cache(self):
        """Ï∫êÏãú Ï†ïÎ¶¨"""
        try:
            with self._lock:
                self._step_cache.clear()
                self.dependency_resolver.clear_cache()
                self.logger.info("üßπ StepFactory Ï∫êÏãú Ï†ïÎ¶¨ ÏôÑÎ£å")
        except Exception as e:
            self.logger.error(f"‚ùå Ï∫êÏãú Ï†ïÎ¶¨ Ïã§Ìå®: {e}")
    
    def validate_dependencies(self) -> Dict[str, bool]:
        """ÏùòÏ°¥ÏÑ± Í≤ÄÏ¶ù"""
        try:
            validation_results = {}
            
            # ModelLoader Í≤ÄÏ¶ù
            model_loader = self.dependency_resolver.resolve_model_loader()
            validation_results['model_loader'] = model_loader is not None
            
            # MemoryManager Í≤ÄÏ¶ù
            memory_manager = self.dependency_resolver.resolve_memory_manager()
            validation_results['memory_manager'] = memory_manager is not None
            
            # DataConverter Í≤ÄÏ¶ù
            data_converter = self.dependency_resolver.resolve_data_converter()
            validation_results['data_converter'] = data_converter is not None
            
            # DI Container Í≤ÄÏ¶ù
            di_container = self.dependency_resolver.resolve_di_container()
            validation_results['di_container'] = di_container is not None
            
            # BaseStepMixin Í≤ÄÏ¶ù
            for step_type in StepType:
                step_class = self.dependency_resolver.resolve_step_mixin_class(step_type)
                validation_results[f'step_class_{step_type.value}'] = step_class is not None
            
            return validation_results
            
        except Exception as e:
            self.logger.error(f"‚ùå ÏùòÏ°¥ÏÑ± Í≤ÄÏ¶ù Ïã§Ìå®: {e}")
            return {}

# ==============================================
# üî• Ï†ÑÏó≠ StepFactory Í¥ÄÎ¶¨
# ==============================================

_global_step_factory: Optional[StepFactory] = None
_factory_lock = threading.Lock()

def get_global_step_factory() -> StepFactory:
    """Ï†ÑÏó≠ StepFactory Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò"""
    global _global_step_factory
    
    with _factory_lock:
        if _global_step_factory is None:
            _global_step_factory = StepFactory()
            logger.info("‚úÖ Ï†ÑÏó≠ StepFactory ÏÉùÏÑ± ÏôÑÎ£å")
        
        return _global_step_factory

# ==============================================
# üî• Ìé∏Ïùò Ìï®ÏàòÎì§
# ==============================================

def create_step(
    step_type: Union[StepType, str], 
    config: Optional[StepConfig] = None,
    **kwargs
) -> StepCreationResult:
    """Ï†ÑÏó≠ Step ÏÉùÏÑ± Ìï®Ïàò"""
    factory = get_global_step_factory()
    return factory.create_step(step_type, config, **kwargs)

async def create_step_async(
    step_type: Union[StepType, str], 
    config: Optional[StepConfig] = None,
    **kwargs
) -> StepCreationResult:
    """Ï†ÑÏó≠ ÎπÑÎèôÍ∏∞ Step ÏÉùÏÑ± Ìï®Ïàò"""
    factory = get_global_step_factory()
    return await factory.create_step_async(step_type, config, **kwargs)

def create_human_parsing_step(**kwargs) -> StepCreationResult:
    """Human Parsing Step ÏÉùÏÑ±"""
    return create_step(StepType.HUMAN_PARSING, **kwargs)

def create_pose_estimation_step(**kwargs) -> StepCreationResult:
    """Pose Estimation Step ÏÉùÏÑ±"""
    return create_step(StepType.POSE_ESTIMATION, **kwargs)

def create_cloth_segmentation_step(**kwargs) -> StepCreationResult:
    """Cloth Segmentation Step ÏÉùÏÑ±"""
    return create_step(StepType.CLOTH_SEGMENTATION, **kwargs)

def create_virtual_fitting_step(**kwargs) -> StepCreationResult:
    """Virtual Fitting Step ÏÉùÏÑ±"""
    return create_step(StepType.VIRTUAL_FITTING, **kwargs)

def create_full_pipeline(device: str = "auto", **kwargs) -> Dict[str, StepCreationResult]:
    """Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±"""
    factory = get_global_step_factory()
    return factory.create_full_pipeline(device, **kwargs)

async def create_full_pipeline_async(device: str = "auto", **kwargs) -> Dict[str, StepCreationResult]:
    """ÎπÑÎèôÍ∏∞ Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±"""
    factory = get_global_step_factory()
    return await factory.create_full_pipeline_async(device, **kwargs)

def validate_step_dependencies() -> Dict[str, bool]:
    """Step ÏùòÏ°¥ÏÑ± Í≤ÄÏ¶ù"""
    factory = get_global_step_factory()
    return factory.validate_dependencies()

def get_step_factory_statistics() -> Dict[str, Any]:
    """StepFactory ÌÜµÍ≥Ñ Ï°∞Ìöå"""
    factory = get_global_step_factory()
    return factory.get_creation_statistics()

def clear_step_factory_cache():
    """StepFactory Ï∫êÏãú Ï†ïÎ¶¨"""
    factory = get_global_step_factory()
    factory.clear_cache()

# ==============================================
# üî• Export
# ==============================================

__all__ = [
    # Î©îÏù∏ ÌÅ¥ÎûòÏä§Îì§
    'StepFactory',
    'DependencyResolver',
    
    # Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞Îì§
    'StepType',
    'StepPriority',
    'StepConfig',
    'StepCreationResult',
    'DependencyBundle',
    
    # Ï†ÑÏó≠ Ìï®ÏàòÎì§
    'get_global_step_factory',
    
    # Ìé∏Ïùò Ìï®ÏàòÎì§
    'create_step',
    'create_step_async',
    'create_human_parsing_step',
    'create_pose_estimation_step',
    'create_cloth_segmentation_step',
    'create_virtual_fitting_step',
    'create_full_pipeline',
    'create_full_pipeline_async',
    
    # Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
    'validate_step_dependencies',
    'get_step_factory_statistics',
    'clear_step_factory_cache'
]

# Î™®Îìà Î°úÎìú ÏôÑÎ£å
logger.info("=" * 80)
logger.info("üè≠ StepFactory v5.0 - ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ Ìå®ÌÑ¥ + ÏàúÌôòÏ∞∏Ï°∞ ÏôÑÏ†Ñ Ìï¥Í≤∞")
logger.info("=" * 80)
logger.info("‚úÖ TYPE_CHECKING Ìå®ÌÑ¥ÏúºÎ°ú ÏàúÌôòÏ∞∏Ï°∞ ÏôÑÏ†Ñ Î∞©ÏßÄ")
logger.info("‚úÖ ÌÜµÌï©Îêú ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ ÏãúÏä§ÌÖú")
logger.info("‚úÖ ÌëúÏ§ÄÌôîÎêú Step ÏÉùÏÑ± Ìå®ÌÑ¥")
logger.info("‚úÖ Î™®Îì† Step ÌÅ¥ÎûòÏä§ Ìò∏ÌôòÏÑ± Î≥¥Ïû•")
logger.info("‚úÖ Ìñ•ÏÉÅÎêú ÏóêÎü¨ Ï≤òÎ¶¨")
logger.info("‚úÖ ÎπÑÎèôÍ∏∞ Step ÏÉùÏÑ± ÏßÄÏõê")
logger.info("‚úÖ Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ± Í∏∞Îä•")
logger.info("‚úÖ ÏïΩÌïú Ï∞∏Ï°∞ Í∏∞Î∞ò Ï∫êÏã±")
logger.info("‚úÖ ÌîÑÎ°úÎçïÏÖò Î†àÎ≤® ÏïàÏ†ïÏÑ±")
logger.info("=" * 80)