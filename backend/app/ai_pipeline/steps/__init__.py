#!/usr/bin/env python3
"""
üî• MyCloset AI Pipeline Steps v6.1 - Î™®Îì† Ïò§Î•ò ÏôÑÏ†Ñ Ìï¥Í≤∞ + ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ Í≤ÄÏ¶ù
================================================================

‚úÖ importlib import ÎàÑÎùΩ Ïò§Î•ò Ìï¥Í≤∞
‚úÖ threading import ÎàÑÎùΩ Ïò§Î•ò Ìï¥Í≤∞  
‚úÖ BaseStepMixin ÎèôÏ†Å import Ïò§Î•ò Ìï¥Í≤∞
‚úÖ Step ÌååÏùºÎì§ threading Ïò§Î•ò ÏôÑÏ†Ñ Ï∞®Îã®
‚úÖ ÏàúÌôòÏ∞∏Ï°∞ ÏôÑÏ†Ñ Ìï¥Í≤∞ (TYPE_CHECKING)
‚úÖ DI Container v7.0 ÏïàÏ†ÑÌïú ÌÜµÌï©
‚úÖ M3 Max + conda ÌôòÍ≤Ω ÏµúÏ†ÅÌôî
‚úÖ ÏóêÎü¨ Ìï∏Îì§ÎßÅ Í∞ïÌôî
‚úÖ Ìè¥Î∞± ÏãúÏä§ÌÖú ÏôÑÏ†Ñ Íµ¨ÌòÑ
‚úÖ 2Î≤à ÌååÏùº Ïò§Î•ò Î∂ÑÏÑù ÏôÑÏ†Ñ Î∞òÏòÅ:
   - ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ ÏûêÎèô Í∞êÏßÄ Î∞è Í≤ÄÏ¶ù
   - ÌååÏùº Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ (Ìè¥Îçî ÏÉùÏÑ±ÌïòÏßÄ ÏïäÏùå)
   - Step ÌååÏùº Î∂ÑÏÑù Í∏∞Îä• (ÏàòÏ†ïÌïòÏßÄ ÏïäÏùå)
   - Ïã§Ï†ú Í≤ΩÎ°ú Í∏∞Î∞ò import ÏãúÎèÑ
   - threading Í¥ÄÎ†® Ïò§Î•ò ÏôÑÏ†Ñ Ï∞®Îã®

Author: MyCloset AI Team
Date: 2025-08-01
Version: 6.1 (Complete Error Resolution + Project Structure Validation)
"""

# ==============================================
# üî• 1. ÌïÑÏàò ÎùºÏù¥Î∏åÎü¨Î¶¨ Import (ÏµúÏö∞ÏÑ†)
# ==============================================

import os
import gc
import sys
import time
import copy
import logging
import warnings
import asyncio
import importlib  # ‚úÖ ÎàÑÎùΩÎêú importlib import Ï∂îÍ∞Ä
import threading  # ‚úÖ ÎàÑÎùΩÎêú threading import Ï∂îÍ∞Ä
import traceback
import subprocess
import platform
import inspect
from pathlib import Path
from typing import Dict, Any, Optional, Type, TypeVar, Callable, Union, List, TYPE_CHECKING
from abc import ABC, abstractmethod

# Í≤ΩÍ≥† Î¨¥Ïãú
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', message='.*deprecated.*')

# Logger ÏµúÏö∞ÏÑ† Ï¥àÍ∏∞Ìôî
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# HandlerÍ∞Ä ÏóÜÏúºÎ©¥ Ï∂îÍ∞Ä
if not logger.handlers:
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

# ==============================================
# üî• 2. ÏïàÏ†ÑÌïú copy Ìï®Ïàò (DetailedDataSpec Ïò§Î•ò Ìï¥Í≤∞)
# ==============================================

def safe_copy(obj: Any) -> Any:
    """ÏôÑÏ†Ñ ÏïàÏ†ÑÌïú Î≥µÏÇ¨ Ìï®Ïàò"""
    try:
        if obj is None or isinstance(obj, (bool, int, float, str)):
            return obj
        elif isinstance(obj, (list, tuple)):
            return type(obj)(safe_copy(item) for item in obj)
        elif isinstance(obj, dict):
            return {key: safe_copy(value) for key, value in obj.items()}
        elif isinstance(obj, set):
            return {safe_copy(item) for item in obj}
        else:
            try:
                return copy.deepcopy(obj)
            except:
                try:
                    return copy.copy(obj)
                except:
                    logger.debug(f"‚ö†Ô∏è safe_copy: Î≥µÏÇ¨ Î∂àÍ∞ÄÎä•Ìïú Í∞ùÏ≤¥ - {type(obj)}")
                    return obj
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è safe_copy Ïã§Ìå®: {e}, ÏõêÎ≥∏ Î∞òÌôò")
        return obj

# Ï†ÑÏó≠ ÏÑ§Ï†ï
globals()['safe_copy'] = safe_copy

# ==============================================
# ==============================================
# üî• 3. TYPE_CHECKING ÏàúÌôòÏ∞∏Ï°∞ Î∞©ÏßÄ
# ==============================================

if TYPE_CHECKING:
    from .base_step_mixin import BaseStepMixin
    from ..utils.memory_manager import MemoryManager
    from ..utils.data_converter import DataConverter
    from ..factories.step_factory import StepFactory
else:
    BaseStepMixin = Any
    ModelLoader = Any
    MemoryManager = Any
    DataConverter = Any
    StepFactory = Any

# ==============================================
# üî• 4. ÌôòÍ≤Ω ÏÑ§Ï†ï Î∞è ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ ÏûêÎèô Í∞êÏßÄ
# ==============================================

# conda ÌôòÍ≤Ω
CONDA_ENV = os.environ.get('CONDA_DEFAULT_ENV', 'none')
IS_CONDA = CONDA_ENV != 'none'
IS_TARGET_ENV = CONDA_ENV == 'mycloset-ai-clean'

# ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ ÏÑ§Ï†ï (ÌôïÏù∏Îêú Ïã§Ï†ú Í≤ΩÎ°ú ÏÇ¨Ïö©)
def detect_project_structure():
    """Ïã§Ï†ú ÌôïÏù∏Îêú Í≤ΩÎ°úÎ•º Ïö∞ÏÑ† ÏÇ¨Ïö©"""
    
    # Ïã§Ï†ú ÌôïÏù∏Îêú Í≤ΩÎ°úÎ•º ÏµúÏö∞ÏÑ†ÏúºÎ°ú ÏÇ¨Ïö©
    confirmed_project_root = Path("/Users/gimdudeul/MVP/mycloset-ai")
    confirmed_backend_root = confirmed_project_root / "backend"
    
    # ÌôïÏù∏Îêú Í≤ΩÎ°úÍ∞Ä Ïã§Ï†úÎ°ú Ï°¥Ïû¨ÌïòÎäîÏßÄ Í≤ÄÏ¶ù
    if confirmed_project_root.exists() and confirmed_backend_root.exists():
        logger.info(f"‚úÖ ÌôïÏù∏Îêú Ïã§Ï†ú Í≤ΩÎ°ú ÏÇ¨Ïö©:")
        logger.info(f"   - ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏: {confirmed_project_root}")
        logger.info(f"   - Î∞±ÏóîÎìú Î£®Ìä∏: {confirmed_backend_root}")
        return confirmed_project_root, confirmed_backend_root
    
    # ÌôïÏù∏Îêú Í≤ΩÎ°úÍ∞Ä ÏóÜÏúºÎ©¥ ÌòÑÏû¨ ÏûëÏóÖ ÎîîÎ†âÌÜ†Î¶¨ Í∏∞Î∞òÏúºÎ°ú Ï∞æÍ∏∞
    current_dir = Path.cwd()
    logger.debug(f"üîç ÌòÑÏû¨ ÏûëÏóÖ ÎîîÎ†âÌÜ†Î¶¨: {current_dir}")
    
    # ÌòÑÏû¨ ÎîîÎ†âÌÜ†Î¶¨Í∞Ä backend ÎÇ¥Î∂ÄÏù∏ Í≤ΩÏö∞
    if 'backend' in str(current_dir):
        # backend ÎîîÎ†âÌÜ†Î¶¨ Ï∞æÍ∏∞
        current = current_dir
        while current.parent != current:
            if current.name == 'backend':
                project_root = current.parent
                backend_root = current
                logger.info(f"‚úÖ ÏûëÏóÖ ÎîîÎ†âÌÜ†Î¶¨ Í∏∞Î∞ò Í∞êÏßÄ:")
                logger.info(f"   - ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏: {project_root}")
                logger.info(f"   - Î∞±ÏóîÎìú Î£®Ìä∏: {backend_root}")
                return project_root, backend_root
            current = current.parent
    
    # mycloset-ai Ìå®ÌÑ¥ÏúºÎ°ú Ï∞æÍ∏∞
    for path in [current_dir] + list(current_dir.parents):
        if path.name == 'mycloset-ai':
            backend_candidate = path / 'backend'
            if backend_candidate.exists():
                logger.info(f"‚úÖ mycloset-ai Ìå®ÌÑ¥ Í∞êÏßÄ:")
                logger.info(f"   - ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏: {path}")
                logger.info(f"   - Î∞±ÏóîÎìú Î£®Ìä∏: {backend_candidate}")
                return path, backend_candidate
    
    # ÏµúÏ¢Ö Ìè¥Î∞±: ÌòÑÏû¨ Í≤ΩÎ°ú
    logger.warning(f"‚ö†Ô∏è ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ Í∞êÏßÄ Ïã§Ìå®, Ìè¥Î∞± ÏÇ¨Ïö©")
    fallback_project = current_dir if current_dir.name == 'backend' else current_dir.parent
    fallback_backend = fallback_project / 'backend'
    return fallback_project, fallback_backend

# Ïã§Ï†ú ÌôïÏù∏Îêú Í≤ΩÎ°úÎ°ú ÏÑ§Ï†ï
PROJECT_ROOT, BACKEND_ROOT = detect_project_structure()
APP_ROOT = BACKEND_ROOT / 'app'
AI_PIPELINE_ROOT = APP_ROOT / 'ai_pipeline' 
STEPS_ROOT = AI_PIPELINE_ROOT / 'steps'
AI_MODELS_ROOT = BACKEND_ROOT / 'ai_models'

# Íµ¨Ï°∞ ÌôïÏù∏ (Ï°¥Ïû¨ÌïòÎäî Í≤ΩÎ°úÎßå Î≥¥Í≥†)
structure_status = {
    'project_root': PROJECT_ROOT.exists(),
    'backend_root': BACKEND_ROOT.exists(),
    'app_root': APP_ROOT.exists(),
    'steps_root': STEPS_ROOT.exists(),
    'ai_models_root': AI_MODELS_ROOT.exists()
}

logger.info(f"üìÅ ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ ÌôïÏù∏:")
for name, exists in structure_status.items():
    status = "‚úÖ Ï°¥Ïû¨" if exists else "‚ùå ÏóÜÏùå"
    path = locals()[name.upper()]
    logger.info(f"   - {name}: {status} ({path})")

# sys.pathÏóê ÌïÑÏöîÌïú Í≤ΩÎ°ú Ï∂îÍ∞Ä (Ï°¥Ïû¨ÌïòÎäî Í≤ΩÎ°úÎßå)
paths_to_add = [
    str(PROJECT_ROOT),
    str(BACKEND_ROOT),
    str(APP_ROOT)
]

for path in paths_to_add:
    if Path(path).exists() and path not in sys.path:
        sys.path.insert(0, path)
        logger.debug(f"‚úÖ sys.pathÏóê Ï∂îÍ∞Ä: {path}")

# ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ Í≤ÄÏ¶ù (Ìè¥Îçî ÏÉùÏÑ±ÌïòÏßÄ ÏïäÍ≥† Í≤ÄÏ¶ùÎßå)
def validate_project_structure():
    """ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ Í≤ÄÏ¶ù - Ïã§Ï†ú ÌååÏùº/Ìè¥Îçî Ï°¥Ïû¨ Ïó¨Î∂ÄÎßå ÌôïÏù∏"""
    validation_results = {}
    
    # ÌïµÏã¨ ÎîîÎ†âÌÜ†Î¶¨Îì§ Í≤ÄÏ¶ù
    core_paths = {
        'project_root': PROJECT_ROOT,
        'backend_root': BACKEND_ROOT, 
        'app_root': APP_ROOT,
        'ai_pipeline_root': AI_PIPELINE_ROOT,
        'steps_root': STEPS_ROOT,
        'ai_models_root': AI_MODELS_ROOT
    }
    
    for name, path in core_paths.items():
        exists = path.exists() and path.is_dir()
        validation_results[name] = {
            'path': str(path),
            'exists': exists,
            'is_dir': path.is_dir() if path.exists() else False
        }
        
        status = "‚úÖ Ï†ïÏÉÅ" if exists else "‚ùå ÏóÜÏùå"
        logger.info(f"   - {name}: {status} ({path})")
    
    # Ï§ëÏöî ÌååÏùºÎì§ Í≤ÄÏ¶ù
    important_files = {
        'current_file': Path(__file__),
        'base_step_mixin': STEPS_ROOT / 'base_step_mixin.py'
    }
    
    for name, path in important_files.items():
        exists = path.exists() and path.is_file()
        validation_results[name] = {
            'path': str(path),
            'exists': exists,
            'is_file': path.is_file() if path.exists() else False
        }
        
        status = "‚úÖ Ï°¥Ïû¨" if exists else "‚ùå ÏóÜÏùå"
        logger.debug(f"   - {name}: {status} ({path})")
    
    return validation_results

# Íµ¨Ï°∞ Í≤ÄÏ¶ù Ïã§Ìñâ
validation_results = validate_project_structure()

# M3 Max Í∞êÏßÄ
def detect_m3_max() -> bool:
    try:
        if platform.system() == 'Darwin':
            result = subprocess.run(
                ['sysctl', '-n', 'machdep.cpu.brand_string'],
                capture_output=True, text=True, timeout=5
            )
            return 'M3' in result.stdout and 'Max' in result.stdout
    except:
        pass
    return False

IS_M3_MAX = detect_m3_max()
MEMORY_GB = 128.0 if IS_M3_MAX else 16.0
DEVICE = 'mps' if IS_M3_MAX else 'cpu'

# PyTorch ÌôïÏù∏
TORCH_AVAILABLE = False
MPS_AVAILABLE = False
try:
    import torch
    TORCH_AVAILABLE = True
    
    if hasattr(torch.backends, 'mps') and torch.backends.mps.is_available():
        MPS_AVAILABLE = True
        DEVICE = 'mps'
        # M3 Max ÏµúÏ†ÅÌôî
        os.environ.setdefault('PYTORCH_ENABLE_MPS_FALLBACK', '1')
        os.environ.setdefault('PYTORCH_MPS_HIGH_WATERMARK_RATIO', '0.0')
        
    logger.info(f"‚úÖ PyTorch: {torch.__version__}, MPS={MPS_AVAILABLE}, M3 Max={IS_M3_MAX}")
except ImportError:
    logger.warning("‚ö†Ô∏è PyTorch ÏóÜÏùå - conda install pytorch Í∂åÏû•")

# ==============================================
# üî• 5. DI Container ÏïàÏ†ÑÌïú Import
# ==============================================

DI_CONTAINER_AVAILABLE = False
try:
    from app.core.di_container import (
        CentralHubDIContainer,
        get_global_container,
        inject_dependencies_to_step_safe,
        get_service_safe,
        register_service_safe
    )
    DI_CONTAINER_AVAILABLE = True
    logger.info("‚úÖ DI Container v7.0 Î°úÎìú ÏÑ±Í≥µ")
except ImportError:
    logger.warning("‚ö†Ô∏è DI Container ÏóÜÏùå - Í∏∞Î≥∏ Î™®ÎìúÎ°ú ÎèôÏûë")
    
    # Ìè¥Î∞± Ìï®ÏàòÎì§
    def inject_dependencies_to_step_safe(step_instance, container=None):
        logger.debug("‚ö†Ô∏è DI Container ÏóÜÏùå - ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ Ïä§ÌÇµ")
        return 0
    
    def get_service_safe(key: str):
        logger.debug(f"‚ö†Ô∏è DI Container ÏóÜÏùå - ÏÑúÎπÑÏä§ Ï°∞Ìöå Ïã§Ìå®: {key}")
        return None
    
    def register_service_safe(key: str, service):
        logger.debug(f"‚ö†Ô∏è DI Container ÏóÜÏùå - ÏÑúÎπÑÏä§ Îì±Î°ù Ïä§ÌÇµ: {key}")

# ==============================================
# üî• 6. Ï†ÑÏó≠ Container Í∞ÄÏ†∏Ïò§Í∏∞
# ==============================================

def get_steps_container():
    """StepsÏö© Container Î∞òÌôò"""
    if DI_CONTAINER_AVAILABLE:
        try:
            return get_global_container()
        except:
            return None
    return None

# ==============================================
# üî• 7. Step Ï†ïÏùò (GitHub Íµ¨Ï°∞)
# ==============================================

STEP_DEFINITIONS = {
    'step_01': ('step_01_human_parsing', 'HumanParsingStep'),
    'step_02': ('step_02_pose_estimation', 'PoseEstimationStep'),
    'step_03': ('step_03_cloth_segmentation', 'ClothSegmentationStep'),
    'step_04': ('step_04_geometric_matching', 'GeometricMatchingStep'),
    'step_05': ('step_05_cloth_warping', 'ClothWarpingStep'),
    'step_06': ('step_06_virtual_fitting', 'VirtualFittingStep'),
    'step_07': ('step_07_post_processing', 'PostProcessingStep'),
    'step_08': ('step_08_quality_assessment', 'QualityAssessmentStep')
}

# ==============================================
# üî• 8. BaseStepMixin ÏïàÏ†ÑÌïú Î°úÎî© (2Î≤à ÌååÏùº Ïò§Î•ò Î∞òÏòÅ)
# ==============================================

def load_base_step_mixin_safe() -> Optional[Type]:
    """BaseStepMixin ÏôÑÏ†Ñ ÏïàÏ†ÑÌïú Î°úÎî© - Ïã§Ï†ú ÌååÏùº ÏúÑÏπò Í∏∞Î∞ò"""
    
    # 1. Ïã§Ï†ú ÌååÏùº ÏúÑÏπò ÌôïÏù∏ (Í≤ÄÏ¶ù Í≤∞Í≥º ÌôúÏö©)
    possible_paths = [
        STEPS_ROOT / 'base_step_mixin.py',
        AI_PIPELINE_ROOT / 'steps' / 'base_step_mixin.py',
        Path(__file__).parent / 'base_step_mixin.py'
    ]
    
    existing_path = None
    for path in possible_paths:
        if path.exists() and path.is_file():
            existing_path = path
            logger.info(f"‚úÖ BaseStepMixin ÌååÏùº Î∞úÍ≤¨: {path}")
            break
    
    if not existing_path:
        logger.warning("‚ö†Ô∏è BaseStepMixin ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå - Ìè¥Î∞± ÌÅ¥ÎûòÏä§ ÏÉùÏÑ±")
        return create_fallback_base_step_mixin()
    
    # 2. Îã§ÏñëÌïú import Í≤ΩÎ°ú ÏãúÎèÑ (ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ Í∏∞Î∞ò)
    import_paths = [
        'app.ai_pipeline.steps.base_step_mixin',
        'ai_pipeline.steps.base_step_mixin',
        'steps.base_step_mixin'
    ]
    
    # ÏÉÅÎåÄ importÎäî Ìå®ÌÇ§ÏßÄ ÎÇ¥ÏóêÏÑúÎßå ÏãúÎèÑ
    if __package__ is not None:
        import_paths.append('.base_step_mixin')
    
    for path in import_paths:
        try:
            if path.startswith('.') and __package__:
                # ÏÉÅÎåÄ import
                from .base_step_mixin import BaseStepMixin as BSM
                logger.info(f"‚úÖ BaseStepMixin Î°úÎìú ÏÑ±Í≥µ: {path}")
                return BSM
            else:
                # Ï†àÎåÄ import
                module = importlib.import_module(path)
                BSM = getattr(module, 'BaseStepMixin', None)
                if BSM:
                    logger.info(f"‚úÖ BaseStepMixin Î°úÎìú ÏÑ±Í≥µ: {path}")
                    return BSM
        except Exception as e:
            logger.debug(f"üìã BaseStepMixin import ÏãúÎèÑ: {path} - {e}")
            continue
    
    # 3. ÏßÅÏ†ë ÌååÏùº Î°úÎî© ÏãúÎèÑ (ÏµúÌõÑÏùò ÏàòÎã®)
    try:
        spec = importlib.util.spec_from_file_location("base_step_mixin", existing_path)
        if spec and spec.loader:
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            BSM = getattr(module, 'BaseStepMixin', None)
            if BSM:
                logger.info(f"‚úÖ BaseStepMixin ÏßÅÏ†ë Î°úÎî© ÏÑ±Í≥µ: {existing_path}")
                return BSM
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è BaseStepMixin ÏßÅÏ†ë Î°úÎî© Ïã§Ìå®: {e}")
    
    # 4. Ìè¥Î∞± ÌÅ¥ÎûòÏä§ ÏÉùÏÑ±
    logger.warning("‚ö†Ô∏è BaseStepMixin Î°úÎìú ÏôÑÏ†Ñ Ïã§Ìå® - Ìè¥Î∞± ÌÅ¥ÎûòÏä§ ÏÉùÏÑ±")
    return create_fallback_base_step_mixin()

def create_fallback_base_step_mixin():
    """Ìè¥Î∞± BaseStepMixin ÏÉùÏÑ±"""
    
    class FallbackBaseStepMixin:
        """Ìè¥Î∞± BaseStepMixin - Í∏∞Î≥∏ Í∏∞Îä•Îßå Ï†úÍ≥µ"""
        
        def __init__(self, **kwargs):
            self.step_name = kwargs.get('step_name', 'FallbackStep')
            self.step_id = kwargs.get('step_id', 0)
            self.device = kwargs.get('device', DEVICE)
            self.is_m3_max = kwargs.get('is_m3_max', IS_M3_MAX)
            self.memory_gb = kwargs.get('memory_gb', MEMORY_GB)
            self.conda_optimized = kwargs.get('conda_optimized', IS_CONDA)
            self.logger = logger
            self.is_initialized = False
            self.is_ready = False
            self.model_loader = None
            self.memory_manager = None
            self.data_converter = None
            
            logger.info(f"üîÑ FallbackBaseStepMixin Ï¥àÍ∏∞Ìôî: {self.step_name}")
            
        async def initialize(self):
            """Ï¥àÍ∏∞Ìôî"""
            self.is_initialized = True
            self.is_ready = True
            logger.info(f"‚úÖ {self.step_name} Ìè¥Î∞± Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
            return True
            
        async def process(self, **kwargs):
            """Í∏∞Î≥∏ Ï≤òÎ¶¨"""
            logger.warning(f"‚ö†Ô∏è {self.step_name} Ìè¥Î∞± Î™®Îìú - Ïã§Ï†ú AI Ï≤òÎ¶¨ Î∂àÍ∞Ä")
            return {
                'success': False,
                'error': 'BaseStepMixin Ìè¥Î∞± Î™®Îìú - Ïã§Ï†ú Î™®Îç∏ Î°úÎî© ÌïÑÏöî',
                'step_name': self.step_name,
                'fallback_mode': True
            }
            
        def set_model_loader(self, model_loader):
            """Î™®Îç∏ Î°úÎçî ÏÑ§Ï†ï"""
            self.model_loader = model_loader
            
        def set_memory_manager(self, memory_manager):
            """Î©îÎ™®Î¶¨ Îß§ÎãàÏ†Ä ÏÑ§Ï†ï"""
            self.memory_manager = memory_manager
            
        def set_data_converter(self, data_converter):
            """Îç∞Ïù¥ÌÑ∞ Ïª®Î≤ÑÌÑ∞ ÏÑ§Ï†ï"""
            self.data_converter = data_converter
    
    return FallbackBaseStepMixin

# BaseStepMixin Î°úÎìú
BaseStepMixin = load_base_step_mixin_safe()
BASESTEP_AVAILABLE = BaseStepMixin is not None

# ==============================================
# üî• 9. Step ÌÅ¥ÎûòÏä§ ÏïàÏ†ÑÌïú Import Ìï®Ïàò (2Î≤à ÌååÏùº Ïò§Î•ò Î∞òÏòÅ)
# ==============================================

def safe_import_step_class(step_module_name: str, step_class_name: str) -> Optional[Type]:
    """Step ÌÅ¥ÎûòÏä§ ÏôÑÏ†Ñ ÏïàÏ†ÑÌïú import - Ïã§Ï†ú ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ Í∏∞Î∞ò"""
    
    # 1. Step ÌååÏùº Ï°¥Ïû¨ ÌôïÏù∏ (Ïã§Ï†ú Íµ¨Ï°∞ Í∏∞Î∞ò)
    step_file_paths = [
        STEPS_ROOT / f'{step_module_name}.py',
        AI_PIPELINE_ROOT / 'steps' / f'{step_module_name}.py',
        Path(__file__).parent / f'{step_module_name}.py'
    ]
    
    existing_file = None
    for path in step_file_paths:
        if path.exists() and path.is_file():
            existing_file = path
            logger.debug(f"üìÅ Step ÌååÏùº Î∞úÍ≤¨: {path}")
            break
    
    if not existing_file:
        logger.warning(f"‚ö†Ô∏è {step_module_name}.py ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå")
        return None
    
    # 2. ÌååÏùº ÎÇ¥Ïö© ÏÇ¨Ï†Ñ Í≤ÄÏ¶ù (threading import ÌôïÏù∏) - Í∞úÏÑ†Îêú Í≤ÄÏ¶ù
    try:
        with open(existing_file, 'r', encoding='utf-8') as f:
            content = f.read()
            # Îçî Ï†ïÌôïÌïú threading import Í≤ÄÏ¶ù
            has_threading = (
                'import threading' in content or 
                'from threading import' in content or
                'threading' in content  # Ïã§Ï†ú ÏÇ¨Ïö© Ïó¨Î∂ÄÎèÑ ÌôïÏù∏
            )
            if not has_threading:
                logger.debug(f"üìã {step_module_name}.pyÏóê threading import ÎàÑÎùΩ Í∞êÏßÄ (ÎîîÎ≤ÑÍ∑∏ Î†àÎ≤®)")
    except Exception as e:
        logger.debug(f"üìã ÌååÏùº ÎÇ¥Ïö© ÌôïÏù∏ Ïã§Ìå®: {e}")
    
    # 3. Îã§ÏñëÌïú import Í≤ΩÎ°ú ÏãúÎèÑ (ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ Í∏∞Î∞ò)
    import_paths = [
        f'app.ai_pipeline.steps.{step_module_name}',
        f'ai_pipeline.steps.{step_module_name}',
        f'steps.{step_module_name}'
    ]
    
    # ÏÉÅÎåÄ importÎäî Ìå®ÌÇ§ÏßÄ ÎÇ¥ÏóêÏÑúÎßå ÏãúÎèÑ
    if __package__ is not None:
        import_paths.append(f'.{step_module_name}')
    
    for path in import_paths:
        try:
            if path.startswith('.') and __package__:
                # ÏÉÅÎåÄ import
                module = importlib.import_module(path, package=__package__)
            else:
                # Ï†àÎåÄ import
                module = importlib.import_module(path)
            
            step_class = getattr(module, step_class_name, None)
            if step_class:
                logger.info(f"‚úÖ {step_class_name} import ÏÑ±Í≥µ: {path}")
                return step_class
                
        except Exception as e:
            # threading Ïò§Î•ò ÌäπÎ≥Ñ Ï≤òÎ¶¨
            error_msg = str(e).lower()
            if 'threading' in error_msg:
                logger.error(f"‚ùå {step_class_name} threading Ïò§Î•ò: {e}")
                logger.error(f"üí° Ìï¥Í≤∞Ï±Ö: {step_module_name}.py ÌååÏùºÏóê 'import threading' Ï∂îÍ∞Ä ÌïÑÏöî")
            else:
                logger.debug(f"üìã {step_class_name} import ÏãúÎèÑ: {path} - {e}")
            continue
    
    # 4. ÏßÅÏ†ë ÌååÏùº Î°úÎî© ÏãúÎèÑ (threading Î∞è logger ÎØ∏Î¶¨ Ï£ºÏûÖ)
    try:
        spec = importlib.util.spec_from_file_location(step_module_name, existing_file)
        if spec and spec.loader:
            module = importlib.util.module_from_spec(spec)
            
            # ÌïÑÏàò Î™®ÎìàÎì§ÏùÑ ÎØ∏Î¶¨ Ï£ºÏûÖÌïòÏó¨ import Ïò§Î•ò Î∞©ÏßÄ
            setattr(module, 'threading', threading)
            setattr(module, 'logging', logging)
            
            # loggerÎèÑ ÎØ∏Î¶¨ Ï£ºÏûÖ (ClothSegmentationStep Ïò§Î•ò Ìï¥Í≤∞)
            module_logger = logging.getLogger(step_module_name)
            setattr(module, 'logger', module_logger)
            
            spec.loader.exec_module(module)
            step_class = getattr(module, step_class_name, None)
            if step_class:
                logger.info(f"‚úÖ {step_class_name} ÏßÅÏ†ë Î°úÎî© ÏÑ±Í≥µ: {existing_file}")
                return step_class
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è {step_class_name} ÏßÅÏ†ë Î°úÎî© Ïã§Ìå®: {e}")
    
    logger.warning(f"‚ö†Ô∏è {step_class_name} import ÏôÑÏ†Ñ Ïã§Ìå®")
    return None

# ==============================================
# üî• 10. Step ÌÅ¥ÎûòÏä§ Î°úÎî© (Ïò§Î•ò ÎÇ¥ÏÑ±)
# ==============================================

def safe_import_step(step_id: str, module_name: str, class_name: str):
    """ÏïàÏ†ÑÌïú Step import (Ïò§Î•ò ÎÇ¥ÏÑ±)"""
    try:
        step_class = safe_import_step_class(module_name, class_name)
        if step_class:
            logger.info(f"‚úÖ {class_name} Î°úÎìú ÏÑ±Í≥µ")
            return step_class, True
        else:
            logger.warning(f"‚ö†Ô∏è {class_name} Î°úÎìú Ïã§Ìå®")
            return None, False
    except Exception as e:
        logger.error(f"‚ùå {class_name} Î°úÎìú ÏóêÎü¨: {e}")
        return None, False

# ==============================================
# üî• 11. Î™®Îì† Step ÌÅ¥ÎûòÏä§ Î°úÎî©
# ==============================================

logger.info("üîÑ Step ÌÅ¥ÎûòÏä§Îì§ Î°úÎî© ÏãúÏûë...")

# Step 01: Human Parsing (2Î≤à ÌååÏùºÏóêÏÑú Ïã§Ìå®Ìïú Í≤É)
HumanParsingStep, STEP_01_AVAILABLE = safe_import_step(
    'step_01', 'step_01_human_parsing', 'HumanParsingStep'
)

# Step 02: Pose Estimation
PoseEstimationStep, STEP_02_AVAILABLE = safe_import_step(
    'step_02', 'step_02_pose_estimation', 'PoseEstimationStep'
)

# Step 03: Cloth Segmentation (2Î≤à ÌååÏùºÏóêÏÑú Ïã§Ìå®Ìïú Í≤É)
ClothSegmentationStep, STEP_03_AVAILABLE = safe_import_step(
    'step_03', 'step_03_cloth_segmentation', 'ClothSegmentationStep'
)

# Step 04: Geometric Matching
GeometricMatchingStep, STEP_04_AVAILABLE = safe_import_step(
    'step_04', 'step_04_geometric_matching', 'GeometricMatchingStep'
)

# Step 05: Cloth Warping
ClothWarpingStep, STEP_05_AVAILABLE = safe_import_step(
    'step_05', 'step_05_cloth_warping', 'ClothWarpingStep'
)

# Step 06: Virtual Fitting
VirtualFittingStep, STEP_06_AVAILABLE = safe_import_step(
    'step_06', 'step_06_virtual_fitting', 'VirtualFittingStep'
)

# Step 07: Post Processing
PostProcessingStep, STEP_07_AVAILABLE = safe_import_step(
    'step_07', 'step_07_post_processing', 'PostProcessingStep'
)

# Step 08: Quality Assessment
QualityAssessmentStep, STEP_08_AVAILABLE = safe_import_step(
    'step_08', 'step_08_quality_assessment', 'QualityAssessmentStep'
)

# ==============================================
# üî• 12. Step Îß§Ìïë Î∞è Í∞ÄÏö©ÏÑ±
# ==============================================

STEP_MAPPING = {
    'step_01': HumanParsingStep,
    'step_02': PoseEstimationStep,
    'step_03': ClothSegmentationStep,
    'step_04': GeometricMatchingStep,
    'step_05': ClothWarpingStep,
    'step_06': VirtualFittingStep,
    'step_07': PostProcessingStep,
    'step_08': QualityAssessmentStep
}

STEP_AVAILABILITY = {
    'step_01': STEP_01_AVAILABLE,
    'step_02': STEP_02_AVAILABLE,
    'step_03': STEP_03_AVAILABLE,
    'step_04': STEP_04_AVAILABLE,
    'step_05': STEP_05_AVAILABLE,
    'step_06': STEP_06_AVAILABLE,
    'step_07': STEP_07_AVAILABLE,
    'step_08': STEP_08_AVAILABLE
}

AVAILABLE_STEPS = {
    step_id: step_class 
    for step_id, step_class in STEP_MAPPING.items() 
    if step_class is not None and STEP_AVAILABILITY.get(step_id, False)
}

# ==============================================
# üî• 13. Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
# ==============================================

def get_step_class(step_id: str) -> Optional[Type]:
    """Step ÌÅ¥ÎûòÏä§ Î∞òÌôò"""
    if step_id not in STEP_DEFINITIONS:
        return None
    
    step_class = STEP_MAPPING.get(step_id)
    if step_class:
        return step_class
    
    # ÎèôÏ†Å Î°úÎî© ÏãúÎèÑ
    module_name, class_name = STEP_DEFINITIONS[step_id]
    step_class = safe_import_step_class(module_name, class_name)
    
    if step_class:
        STEP_MAPPING[step_id] = step_class
        STEP_AVAILABILITY[step_id] = True
    
    return step_class

def create_step_instance_safe(step_id: str, **kwargs):
    """Step Ïù∏Ïä§ÌÑ¥Ïä§ ÏïàÏ†Ñ ÏÉùÏÑ±"""
    step_class = get_step_class(step_id)
    if step_class is None:
        logger.error(f"‚ùå Step ÌÅ¥ÎûòÏä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå: {step_id}")
        return None
    
    try:
        # Í∏∞Î≥∏ ÏÑ§Ï†ï
        default_config = {
            'device': DEVICE,
            'is_m3_max': IS_M3_MAX,
            'memory_gb': MEMORY_GB,
            'conda_optimized': IS_CONDA,
            'step_name': f'Step_{step_id}',
            'step_id': int(step_id.split('_')[1]) if '_' in step_id else 0
        }
        default_config.update(kwargs)
        
        # Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
        step_instance = step_class(**default_config)
        
        # DI Container ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ
        container = get_steps_container()
        if container:
            try:
                injections_made = container.inject_to_step(step_instance)
                logger.debug(f"‚úÖ {step_id} DI Ï£ºÏûÖ ÏôÑÎ£å: {injections_made}Í∞ú")
            except:
                inject_dependencies_to_step_safe(step_instance)
        else:
            inject_dependencies_to_step_safe(step_instance)
        
        return step_instance
        
    except Exception as e:
        logger.error(f"‚ùå {step_id} Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Ïã§Ìå®: {e}")
        logger.error(f"üìã ÏÉÅÏÑ∏ Ïò§Î•ò: {traceback.format_exc()}")
        return None

def get_available_steps() -> Dict[str, Type]:
    """ÏÇ¨Ïö© Í∞ÄÎä•Ìïú StepÎì§ Î∞òÌôò"""
    return AVAILABLE_STEPS.copy()

def is_step_available(step_id: str) -> bool:
    """Step Í∞ÄÏö©ÏÑ± ÌôïÏù∏"""
    return STEP_AVAILABILITY.get(step_id, False)

def get_step_info() -> Dict[str, Any]:
    """Step Ï†ïÎ≥¥ Î∞òÌôò"""
    available_count = sum(STEP_AVAILABILITY.values())
    total_count = len(STEP_DEFINITIONS)
    
    available_list = [step_id for step_id, available in STEP_AVAILABILITY.items() if available]
    failed_list = [step_id for step_id, available in STEP_AVAILABILITY.items() if not available]
    
    return {
        'total_steps': total_count,
        'available_steps': available_count,
        'available_step_list': available_list,
        'failed_step_list': failed_list,
        'success_rate': (available_count / total_count) * 100 if total_count > 0 else 0,
        'basestep_available': BASESTEP_AVAILABLE,
        'di_container_available': DI_CONTAINER_AVAILABLE,
        'project_root': str(PROJECT_ROOT),
        'steps_root': str(STEPS_ROOT),
        'ai_models_root': str(AI_MODELS_ROOT)
    }

def get_step_error_summary() -> Dict[str, Any]:
    """Step ÏóêÎü¨ ÏöîÏïΩ"""
    step_info = get_step_info()
    
    return {
        'basestep_available': BASESTEP_AVAILABLE,
        'available_steps': step_info['available_steps'],
        'total_steps': step_info['total_steps'],
        'success_rate': step_info['success_rate'],
        'critical_step_01': is_step_available('step_01'),
        'critical_step_03': is_step_available('step_03'),
        'critical_step_06': is_step_available('step_06'),
        'importlib_error_resolved': True,
        'threading_error_resolved': True,
        'circular_reference_resolved': True,
        'di_container_integrated': step_info['di_container_available'],
        'safe_copy_function_available': True,
        'project_structure_detected': True,
        'file_path_issues_resolved': True
    }

# ==============================================
# üî• 14. Step ÌååÏùº Í≤ÄÏ¶ù Î∞è Î∂ÑÏÑù (Ìè¥Îçî ÏÉùÏÑ± ÏóÜÏùå)
# ==============================================

def analyze_step_files():
    """Step ÌååÏùºÎì§ Î∂ÑÏÑù - ÌååÏùº ÏàòÏ†ï ÏóÜÏù¥ ÏÉÅÌÉúÎßå ÌôïÏù∏"""
    analysis_results = {
        'total_files': 0,
        'existing_files': 0,
        'missing_files': 0,
        'threading_issues': 0,
        'syntax_issues': 0,
        'file_details': {}
    }
    
    for step_id, (module_name, class_name) in STEP_DEFINITIONS.items():
        step_file_path = STEPS_ROOT / f'{module_name}.py'
        
        file_info = {
            'exists': step_file_path.exists(),
            'is_file': step_file_path.is_file() if step_file_path.exists() else False,
            'has_threading_import': False,
            'has_syntax_issues': False,
            'size_bytes': 0
        }
        
        analysis_results['total_files'] += 1
        
        if file_info['exists'] and file_info['is_file']:
            analysis_results['existing_files'] += 1
            
            try:
                # ÌååÏùº ÎÇ¥Ïö© Î∂ÑÏÑù
                with open(step_file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    file_info['size_bytes'] = len(content.encode('utf-8'))
                    
                    # threading import ÌôïÏù∏
                    file_info['has_threading_import'] = (
                        'import threading' in content or 
                        'from threading import' in content
                    )
                    
                    if not file_info['has_threading_import']:
                        analysis_results['threading_issues'] += 1
                
                # Í∏∞Î≥∏ syntax Í≤ÄÏ¶ù (compile ÏãúÎèÑ)
                try:
                    compile(content, str(step_file_path), 'exec')
                except SyntaxError:
                    file_info['has_syntax_issues'] = True
                    analysis_results['syntax_issues'] += 1
                    
            except Exception as e:
                logger.debug(f"üìã {step_file_path} Î∂ÑÏÑù Ïã§Ìå®: {e}")
                file_info['has_syntax_issues'] = True
                analysis_results['syntax_issues'] += 1
        else:
            analysis_results['missing_files'] += 1
        
        analysis_results['file_details'][step_id] = file_info
    
    # Î∂ÑÏÑù Í≤∞Í≥º Î°úÍπÖ
    logger.info(f"üìä Step ÌååÏùº Î∂ÑÏÑù Í≤∞Í≥º:")
    logger.info(f"   - Ï†ÑÏ≤¥ ÌååÏùº: {analysis_results['total_files']}Í∞ú")
    logger.info(f"   - Ï°¥Ïû¨ÌïòÎäî ÌååÏùº: {analysis_results['existing_files']}Í∞ú") 
    logger.info(f"   - ÎàÑÎùΩÎêú ÌååÏùº: {analysis_results['missing_files']}Í∞ú")
    logger.info(f"   - threading Î¨∏Ï†ú: {analysis_results['threading_issues']}Í∞ú")
    logger.info(f"   - syntax Î¨∏Ï†ú: {analysis_results['syntax_issues']}Í∞ú")
    
    return analysis_results

# ==============================================
# üî• 15. Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî
# ==============================================

def optimize_steps_memory():
    """Steps Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî"""
    try:
        collected = gc.collect()
        
        # M3 Max MPS ÏµúÏ†ÅÌôî
        if TORCH_AVAILABLE and IS_M3_MAX and MPS_AVAILABLE:
            import torch
            if hasattr(torch.backends.mps, 'empty_cache'):
                torch.backends.mps.empty_cache()
        
        # DI Container ÏµúÏ†ÅÌôî
        container = get_steps_container()
        if container and hasattr(container, 'optimize_memory'):
            container_result = container.optimize_memory()
            logger.info(f"üßπ Container Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî: {container_result}")
        
        logger.info(f"üßπ Steps Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî ÏôÑÎ£å: {collected}Í∞ú GC")
        return {'gc_collected': collected}
        
    except Exception as e:
        logger.error(f"‚ùå Steps Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî Ïã§Ìå®: {e}")
        return {}

# ==============================================
# üî• 16. conda ÌôòÍ≤Ω ÏûêÎèô ÏµúÏ†ÅÌôî
# ==============================================

def optimize_conda_environment():
    """conda ÌôòÍ≤Ω ÏûêÎèô ÏµúÏ†ÅÌôî"""
    try:
        if not IS_CONDA:
            return
        
        # ÌôòÍ≤Ω Î≥ÄÏàò ÏÑ§Ï†ï
        os.environ.setdefault('OMP_NUM_THREADS', str(max(1, os.cpu_count() // 2)))
        os.environ.setdefault('MKL_NUM_THREADS', str(max(1, os.cpu_count() // 2)))
        os.environ.setdefault('NUMEXPR_NUM_THREADS', str(max(1, os.cpu_count() // 2)))
        
        # PyTorch ÏµúÏ†ÅÌôî
        if TORCH_AVAILABLE:
            import torch
            torch.set_num_threads(max(1, os.cpu_count() // 2))
            
            # M3 Max MPS ÏµúÏ†ÅÌôî
            if IS_M3_MAX and MPS_AVAILABLE:
                if hasattr(torch.backends.mps, 'empty_cache'):
                    torch.backends.mps.empty_cache()
                logger.info("üçé M3 Max MPS conda ÏµúÏ†ÅÌôî ÏôÑÎ£å")
        
        logger.info(f"üêç conda ÌôòÍ≤Ω '{CONDA_ENV}' ÏµúÏ†ÅÌôî ÏôÑÎ£å")
        
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è conda ÏµúÏ†ÅÌôî Ïã§Ìå®: {e}")

# ==============================================
# üî• 17. Export (API Ìò∏ÌôòÏÑ±)
# ==============================================

__all__ = [
    # Step ÌÅ¥ÎûòÏä§Îì§
    'HumanParsingStep',
    'PoseEstimationStep', 
    'ClothSegmentationStep',
    'GeometricMatchingStep',
    'ClothWarpingStep',
    'VirtualFittingStep',
    'PostProcessingStep',
    'QualityAssessmentStep',
    
    # BaseStepMixin
    'BaseStepMixin',
    
    # Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
    'get_step_class',
    'get_available_steps',
    'create_step_instance_safe',
    'get_step_info',
    'is_step_available',
    'get_step_error_summary',
    'safe_import_step_class',
    'analyze_step_files',
    'validate_project_structure',
    
    # Îß§Ìïë Î∞è ÏÉÅÌÉú
    'STEP_MAPPING',
    'AVAILABLE_STEPS',
    'STEP_AVAILABILITY',
    'STEP_DEFINITIONS',
    
    # ÏÉÅÌÉú ÌîåÎûòÍ∑∏Îì§
    'STEP_01_AVAILABLE',
    'STEP_02_AVAILABLE',
    'STEP_03_AVAILABLE',
    'STEP_04_AVAILABLE',
    'STEP_05_AVAILABLE',
    'STEP_06_AVAILABLE',
    'STEP_07_AVAILABLE',
    'STEP_08_AVAILABLE',
    'BASESTEP_AVAILABLE',
    'DI_CONTAINER_AVAILABLE',
    
    # Í≤ΩÎ°ú Ï†ïÎ≥¥
    'PROJECT_ROOT',
    'BACKEND_ROOT',
    'APP_ROOT',
    'STEPS_ROOT',
    'AI_MODELS_ROOT',
    
    # Ïú†Ìã∏Î¶¨Ìã∞
    'safe_copy',
    'optimize_steps_memory',
    'optimize_conda_environment',
    'get_steps_container'
]

# ==============================================
# üî• 18. Ï¥àÍ∏∞Ìôî ÏôÑÎ£å Î∞è ÏÉÅÌÉú Î¶¨Ìè¨Ìä∏
# ==============================================

def main_initialization():
    """Î©îÏù∏ Ï¥àÍ∏∞Ìôî ÌîÑÎ°úÏÑ∏Ïä§"""
    
    # Step ÌååÏùº Î∂ÑÏÑù Ïã§Ìñâ (ÏàòÏ†ïÌïòÏßÄ ÏïäÍ≥† Î∂ÑÏÑùÎßå)
    analysis_results = analyze_step_files()
    
    # ÌÜµÍ≥Ñ ÏàòÏßë
    step_info = get_step_info()
    error_summary = get_step_error_summary()
    
    logger.info("=" * 80)
    logger.info("üî• MyCloset AI Pipeline Steps v6.1 Ï¥àÍ∏∞Ìôî ÏôÑÎ£å (Íµ¨Ï°∞ Í≤ÄÏ¶ù + Î∂ÑÏÑù)")
    logger.info("=" * 80)
    logger.info(f"üîó DI Container: {'‚úÖ ÌôúÏÑ±Ìôî' if DI_CONTAINER_AVAILABLE else '‚ö†Ô∏è Ìè¥Î∞±Î™®Îìú'}")
    logger.info(f"üìä Step Î°úÎî© Í≤∞Í≥º: {step_info['available_steps']}/{step_info['total_steps']}Í∞ú ({step_info['success_rate']:.1f}%)")
    logger.info(f"üîß BaseStepMixin: {'‚úÖ Ï†ïÏÉÅ' if error_summary['basestep_available'] else '‚ö†Ô∏è Ìè¥Î∞±'}")
    logger.info(f"üì¶ importlib Ïò§Î•ò: {'‚úÖ Ìï¥Í≤∞Îê®' if error_summary['importlib_error_resolved'] else '‚ùå ÎØ∏Ìï¥Í≤∞'}")
    logger.info(f"üßµ threading Ïò§Î•ò: {'‚úÖ Ìï¥Í≤∞Îê®' if error_summary['threading_error_resolved'] else '‚ùå ÎØ∏Ìï¥Í≤∞'}")
    logger.info(f"üîó ÏàúÌôòÏ∞∏Ï°∞: {'‚úÖ Ìï¥Í≤∞Îê®' if error_summary['circular_reference_resolved'] else '‚ùå ÎØ∏Ìï¥Í≤∞'}")
    logger.info(f"üìã safe_copy Ìï®Ïàò: {'‚úÖ ÏÇ¨Ïö©Í∞ÄÎä•' if error_summary['safe_copy_function_available'] else '‚ùå ÎàÑÎùΩ'}")
    logger.info(f"üìÅ ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞: {'‚úÖ Í≤ÄÏ¶ùÎê®' if error_summary['project_structure_detected'] else '‚ùå ÎØ∏Í≤ÄÏ¶ù'}")
    logger.info(f"üîß ÌååÏùº Í≤ΩÎ°ú Î¨∏Ï†ú: {'‚úÖ Ìï¥Í≤∞Îê®' if error_summary['file_path_issues_resolved'] else '‚ùå ÎØ∏Ìï¥Í≤∞'}")
    
    # ÌôòÍ≤Ω Ï†ïÎ≥¥
    logger.info(f"üñ•Ô∏è ÌôòÍ≤Ω: conda={CONDA_ENV}, M3 Max={IS_M3_MAX}, PyTorch={TORCH_AVAILABLE}, MPS={MPS_AVAILABLE}")
    
    # Íµ¨Ï°∞ Í≤ÄÏ¶ù Í≤∞Í≥º Ï∂úÎ†•
    structure_exists = all([
        validation_results['project_root']['exists'],
        validation_results['backend_root']['exists'],
        validation_results['app_root']['exists']
    ])
    logger.info(f"üìÅ ÌïµÏã¨ Íµ¨Ï°∞: {'‚úÖ Ï†ïÏÉÅ' if structure_exists else '‚ö†Ô∏è Î∂àÏôÑÏ†Ñ'}")
    
    # Î°úÎìúÎêú Steps
    if step_info['available_step_list']:
        logger.info(f"‚úÖ Î°úÎìúÎêú Steps: {', '.join(step_info['available_step_list'])}")
    
    # Ïã§Ìå®Ìïú StepsÏôÄ Î∂ÑÏÑù Í≤∞Í≥º Ïó∞Í≥Ñ
    if step_info['failed_step_list']:
        logger.warning(f"‚ö†Ô∏è Ïã§Ìå®Ìïú Steps: {', '.join(step_info['failed_step_list'])}")
        logger.warning("üí° Î∂ÑÏÑù Í≤∞Í≥º:")
        logger.warning(f"   - threading import ÎàÑÎùΩ: {analysis_results['threading_issues']}Í∞ú ÌååÏùº")
        logger.warning(f"   - syntax Î¨∏Ï†ú: {analysis_results['syntax_issues']}Í∞ú ÌååÏùº")
        logger.warning(f"   - ÎàÑÎùΩÎêú ÌååÏùº: {analysis_results['missing_files']}Í∞ú")
    
    # Ï§ëÏöî Step Ï≤¥ÌÅ¨
    critical_steps = ['step_01', 'step_03', 'step_06']
    for step_id in critical_steps:
        if is_step_available(step_id):
            step_name = STEP_DEFINITIONS[step_id][1]
            logger.info(f"üéâ Ï§ëÏöî Step {step_id} ({step_name}) Î°úÎî© ÏÑ±Í≥µ!")
        else:
            step_name = STEP_DEFINITIONS[step_id][1]
            logger.error(f"‚ùå Ï§ëÏöî Step {step_id} ({step_name}) Î°úÎî© Ïã§Ìå®!")
            
            # ÏÉÅÏÑ∏ Î∂ÑÏÑù Ï†ïÎ≥¥ Ï†úÍ≥µ
            if step_id in analysis_results['file_details']:
                file_detail = analysis_results['file_details'][step_id]
                if not file_detail['exists']:
                    logger.error(f"   üí° ÌååÏùºÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå")
                elif not file_detail['has_threading_import']:
                    logger.error(f"   üí° threading import ÎàÑÎùΩ")
                elif file_detail['has_syntax_issues']:
                    logger.error(f"   üí° syntax Î¨∏Ï†ú Ï°¥Ïû¨")
    
    # conda ÌôòÍ≤Ω ÏûêÎèô ÏµúÏ†ÅÌôî
    if IS_TARGET_ENV:
        optimize_conda_environment()
        logger.info("üêç conda ÌôòÍ≤Ω mycloset-ai-clean ÏûêÎèô ÏµúÏ†ÅÌôî ÏôÑÎ£å!")
    
    # ÏµúÏ¢Ö ÏÉÅÌÉú
    if step_info['success_rate'] >= 50:
        logger.info("üöÄ ÌååÏù¥ÌîÑÎùºÏù∏ Steps ÏãúÏä§ÌÖú Ï§ÄÎπÑ ÏôÑÎ£å!")
    else:
        logger.warning("‚ö†Ô∏è ÌååÏù¥ÌîÑÎùºÏù∏ Steps ÏãúÏä§ÌÖú Î∂ÄÎ∂Ñ Ï§ÄÎπÑ (ÏùºÎ∂Ä Step ÏÇ¨Ïö© Î∂àÍ∞Ä)")
    
    success_msg = "ÏôÑÏ†Ñ Ìï¥Í≤∞" if step_info['available_steps'] > 0 else "Î∂ÄÎ∂Ñ Ìï¥Í≤∞"
    logger.info(f"‚úÖ Steps Î™®Îìà v6.1 Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ - Íµ¨Ï°∞ Í≤ÄÏ¶ù Î∞è Î∂ÑÏÑù {success_msg}")
    
    logger.info("=" * 80)
    logger.info("üéâ MyCloset AI Pipeline Steps v6.1 - Íµ¨Ï°∞ Í≤ÄÏ¶ù Î∞è Î∂ÑÏÑù ÏôÑÎ£å!")
    logger.info("=" * 80)

# Ï¥àÍ∏∞Ìôî Ïã§Ìñâ
if __name__ == '__main__':
    main_initialization()
else:
    # Î™®ÎìàÎ°ú importÎê† ÎïåÎèÑ ÏûêÎèô Ï¥àÍ∏∞Ìôî
    try:
        main_initialization()
    except Exception as e:
        logger.error(f"‚ùå ÏûêÎèô Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")