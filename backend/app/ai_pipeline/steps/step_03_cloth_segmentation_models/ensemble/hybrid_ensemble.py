#!/usr/bin/env python3
"""
üî• MyCloset AI - Cloth Segmentation Hybrid Ensemble System
==========================================================

üéØ Îã§Ï§ë Î™®Îç∏ ÏïôÏÉÅÎ∏îÏùÑ ÌÜµÌïú Ï†ïÌôïÎèÑ Ìñ•ÏÉÅ
‚úÖ 8Í∞ú Cloth Segmentation Î™®Îç∏ ÌÜµÌï©
‚úÖ M3 Max ÏµúÏ†ÅÌôî
‚úÖ Î©îÎ™®Î¶¨ Ìö®Ïú®Ï†Å Ï≤òÎ¶¨
‚úÖ ÌíàÏßà Í∏∞Î∞ò Í∞ÄÏ§ëÏπò Ï°∞Ï†ï
"""

# PyTorch import ÏãúÎèÑ
try:
    import torch
    import torch.nn as nn
    import torch.nn.functional as F
    TORCH_AVAILABLE = True
except ImportError:
    TORCH_AVAILABLE = False
    torch = None
    # torchÍ∞Ä ÏóÜÏùÑ ÎïåÎäî Í∏∞Î≥∏ ÌÉÄÏûÖ ÏÇ¨Ïö©
    class MockNNModule:
        """Mock nn.Module (torch ÏóÜÏùå)"""
        pass
    # nn.ModuleÏùÑ MockNNModuleÏúºÎ°ú ÎåÄÏ≤¥
    class nn:
        Module = MockNNModule
    F = None

import numpy as np
import logging
from typing import Dict, List, Tuple, Optional, Union
from dataclasses import dataclass

# Í≥µÌÜµ imports ÏãúÏä§ÌÖú ÏÇ¨Ïö©
try:
    from app.ai_pipeline.utils.common_imports import (
        np, cv2, PIL_AVAILABLE, CV2_AVAILABLE, NUMPY_AVAILABLE
    )
except ImportError:
    import numpy as np
    import cv2

# Î°úÍ±∞ ÏÑ§Ï†ï
logger = logging.getLogger(__name__)

@dataclass
class EnsembleConfig:
    """ÏïôÏÉÅÎ∏î ÏÑ§Ï†ï"""
    method: str = "quality_weighted"  # voting, weighted, quality, simple_average
    quality_threshold: float = 0.7
    confidence_threshold: float = 0.5
    max_models: int = 8
    use_mps: bool = True
    memory_efficient: bool = True

class ClothSegmentationEnsembleSystem(nn.Module):
    """
    üî• Cloth Segmentation ÏïôÏÉÅÎ∏î ÏãúÏä§ÌÖú
    
    Îã§Ï§ë Î™®Îç∏Ïùò Ï∂úÎ†•ÏùÑ ÌÜµÌï©ÌïòÏó¨ ÏµúÏ¢Ö ÏùòÎ•ò Î∂ÑÌï† Í≤∞Í≥ºÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
    """
    
    def __init__(self, config: EnsembleConfig = None):
        super().__init__()
        self.config = config or EnsembleConfig()
        self.logger = logging.getLogger(__name__)
        
        # MPS ÎîîÎ∞îÏù¥Ïä§ ÌôïÏù∏
        self.device = torch.device("mps" if torch.backends.mps.is_available() and self.config.use_mps else "cpu")
        self.logger.info(f"üéØ Cloth Segmentation ÏïôÏÉÅÎ∏î ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî (ÎîîÎ∞îÏù¥Ïä§: {self.device})")
        
        # ÏïôÏÉÅÎ∏î Í∞ÄÏ§ëÏπò Ï¥àÍ∏∞Ìôî
        self.ensemble_weights = nn.Parameter(torch.ones(8) / 8)  # 8Í∞ú Î™®Îç∏
        
        # ÌíàÏßà ÌèâÍ∞Ä Î©îÌä∏Î¶≠
        self.quality_metrics = {
            "confidence": 0.0,
            "spatial_consistency": 0.0,
            "segmentation_quality": 0.0,
            "boundary_accuracy": 0.0
        }
        
        self.logger.info("‚úÖ Cloth Segmentation ÏïôÏÉÅÎ∏î ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def forward(self, model_outputs: List[torch.Tensor], 
                confidences: List[float] = None,
                quality_scores: List[float] = None) -> torch.Tensor:
        """
        ÏïôÏÉÅÎ∏î Ï∂îÎ°† ÏàòÌñâ
    
    Args:
            model_outputs: Í∞Å Î™®Îç∏Ïùò Ï∂úÎ†• (List[torch.Tensor])
            confidences: Í∞Å Î™®Îç∏Ïùò Ïã†Î¢∞ÎèÑ (List[float])
            quality_scores: Í∞Å Î™®Îç∏Ïùò ÌíàÏßà Ï†êÏàò (List[float])
        
    Returns:
            ÏïôÏÉÅÎ∏îÎêú ÏùòÎ•ò Î∂ÑÌï† Í≤∞Í≥º
        """
        if not model_outputs:
            raise ValueError("Î™®Îç∏ Ï∂úÎ†•Ïù¥ ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.")
        
        # ÏûÖÎ†• Í≤ÄÏ¶ù
        num_models = len(model_outputs)
        if num_models > self.config.max_models:
            self.logger.warning(f"Î™®Îç∏ ÏàòÍ∞Ä ÏµúÎåÄ ÌóàÏö©ÏπòÎ•º Ï¥àÍ≥ºÌï©ÎãàÎã§: {num_models} > {self.config.max_models}")
            model_outputs = model_outputs[:self.config.max_models]
        
        # ÎîîÎ∞îÏù¥Ïä§ Ïù¥Îèô
        model_outputs = [output.to(self.device) if isinstance(output, torch.Tensor) else torch.tensor(output, device=self.device) 
                        for output in model_outputs]
        
        # ÏïôÏÉÅÎ∏î Î∞©Î≤ïÏóê Îî∞Î•∏ ÌÜµÌï©
        if self.config.method == "voting":
            ensemble_output = self._voting_ensemble(model_outputs, confidences)
        elif self.config.method == "weighted":
            ensemble_output = self._weighted_ensemble(model_outputs, confidences)
        elif self.config.method == "quality":
            ensemble_output = self._quality_weighted_ensemble(model_outputs, quality_scores)
        elif self.config.method == "simple_average":
            ensemble_output = self._simple_average_ensemble(model_outputs)
        else:
            self.logger.warning(f"Ïïå Ïàò ÏóÜÎäî ÏïôÏÉÅÎ∏î Î∞©Î≤ï: {self.config.method}, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
            ensemble_output = self._quality_weighted_ensemble(model_outputs, quality_scores)
        
        # ÌíàÏßà Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
        self._update_quality_metrics(ensemble_output, model_outputs)
        
        return ensemble_output
    
    def _voting_ensemble(self, model_outputs: List[torch.Tensor], 
                         confidences: List[float] = None) -> torch.Tensor:
        """Ìà¨Ìëú Í∏∞Î∞ò ÏïôÏÉÅÎ∏î"""
        self.logger.debug("üéØ Ìà¨Ìëú Í∏∞Î∞ò ÏïôÏÉÅÎ∏î ÏàòÌñâ")
        
        # Ïã†Î¢∞ÎèÑ Í∏∞Î∞ò Í∞ÄÏ§ëÏπò Í≥ÑÏÇ∞
        if confidences:
            weights = torch.tensor(confidences, device=self.device)
            weights = F.softmax(weights, dim=0)
        else:
            weights = torch.ones(len(model_outputs), device=self.device) / len(model_outputs)
        
        # Í∞ÄÏ§ë ÌèâÍ∑† Í≥ÑÏÇ∞
        ensemble_output = torch.zeros_like(model_outputs[0])
        for i, output in enumerate(model_outputs):
            ensemble_output += weights[i] * output
        
        return ensemble_output
    
    def _weighted_ensemble(self, model_outputs: List[torch.Tensor], 
                          confidences: List[float] = None) -> torch.Tensor:
        """Í∞ÄÏ§ëÏπò Í∏∞Î∞ò ÏïôÏÉÅÎ∏î"""
        self.logger.debug("üéØ Í∞ÄÏ§ëÏπò Í∏∞Î∞ò ÏïôÏÉÅÎ∏î ÏàòÌñâ")
        
        # Ïã†Î¢∞ÎèÑ Í∏∞Î∞ò Í∞ÄÏ§ëÏπò
        if confidences:
            weights = torch.tensor(confidences, device=self.device)
            weights = F.softmax(weights, dim=0)
        else:
            weights = self.ensemble_weights[:len(model_outputs)]
            weights = F.softmax(weights, dim=0)
        
        # Í∞ÄÏ§ë ÌèâÍ∑† Í≥ÑÏÇ∞
        ensemble_output = torch.zeros_like(model_outputs[0])
        for i, output in enumerate(model_outputs):
            ensemble_output += weights[i] * output
        
        return ensemble_output
    
    def _quality_weighted_ensemble(self, model_outputs: List[torch.Tensor], 
                                 quality_scores: List[float] = None) -> torch.Tensor:
        """ÌíàÏßà Í∏∞Î∞ò Í∞ÄÏ§ëÏπò ÏïôÏÉÅÎ∏î"""
        self.logger.debug("üéØ ÌíàÏßà Í∏∞Î∞ò Í∞ÄÏ§ëÏπò ÏïôÏÉÅÎ∏î ÏàòÌñâ")
        
        # ÌíàÏßà Ï†êÏàò Í∏∞Î∞ò Í∞ÄÏ§ëÏπò
        if quality_scores:
            weights = torch.tensor(quality_scores, device=self.device)
            weights = F.softmax(weights, dim=0)
        else:
            # Í∏∞Î≥∏ ÌíàÏßà Ï†êÏàò (Ïã†Î¢∞ÎèÑ Í∏∞Î∞ò)
            weights = torch.ones(len(model_outputs), device=self.device) / len(model_outputs)
        
        # ÌíàÏßà ÏûÑÍ≥ÑÍ∞í Ï†ÅÏö©
        quality_mask = weights > self.config.quality_threshold
        if quality_mask.sum() > 0:
            weights = weights * quality_mask.float()
            weights = F.softmax(weights, dim=0)
        
        # Í∞ÄÏ§ë ÌèâÍ∑† Í≥ÑÏÇ∞
        ensemble_output = torch.zeros_like(model_outputs[0])
        for i, output in enumerate(model_outputs):
            ensemble_output += weights[i] * output
        
        return ensemble_output
    
    def _simple_average_ensemble(self, model_outputs: List[torch.Tensor]) -> torch.Tensor:
        """Îã®Ïàú ÌèâÍ∑† ÏïôÏÉÅÎ∏î"""
        self.logger.debug("üéØ Îã®Ïàú ÌèâÍ∑† ÏïôÏÉÅÎ∏î ÏàòÌñâ")
        
        # Î™®Îì† Î™®Îç∏ Ï∂úÎ†•Ïùò ÌèâÍ∑†
        ensemble_output = torch.stack(model_outputs).mean(dim=0)
        return ensemble_output
    
    def _update_quality_metrics(self, ensemble_output: torch.Tensor, 
                              model_outputs: List[torch.Tensor]):
        """ÌíàÏßà Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏"""
        # Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞
        if ensemble_output.dim() > 0:
            self.quality_metrics["confidence"] = float(ensemble_output.mean().item())
        
        # Í≥µÍ∞Ñ ÏùºÍ¥ÄÏÑ± Í≥ÑÏÇ∞
        if len(model_outputs) > 1:
            spatial_consistency = self._calculate_spatial_consistency(model_outputs)
            self.quality_metrics["spatial_consistency"] = spatial_consistency
        
        # Î∂ÑÌï† ÌíàÏßà Í≥ÑÏÇ∞
        segmentation_quality = self._calculate_segmentation_quality(ensemble_output)
        self.quality_metrics["segmentation_quality"] = segmentation_quality
        
        # Í≤ΩÍ≥Ñ Ï†ïÌôïÎèÑ Í≥ÑÏÇ∞
        boundary_accuracy = self._calculate_boundary_accuracy(ensemble_output)
        self.quality_metrics["boundary_accuracy"] = boundary_accuracy
    
    def _calculate_spatial_consistency(self, model_outputs: List[torch.Tensor]) -> float:
        """Í≥µÍ∞Ñ ÏùºÍ¥ÄÏÑ± Í≥ÑÏÇ∞"""
        if len(model_outputs) < 2:
            return 0.0
        
        # Í∞Å Î™®Îç∏ Ï∂úÎ†• Í∞ÑÏùò Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
        similarities = []
        for i in range(len(model_outputs)):
            for j in range(i + 1, len(model_outputs)):
                sim = F.cosine_similarity(
                    model_outputs[i].flatten(), 
                    model_outputs[j].flatten(), 
                    dim=0
                )
                similarities.append(sim.item())
        
        return float(np.mean(similarities)) if similarities else 0.0
    
    def _calculate_segmentation_quality(self, output: torch.Tensor) -> float:
        """Î∂ÑÌï† ÌíàÏßà Í≥ÑÏÇ∞"""
        if output.dim() == 0:
            return 0.0
        
        # Î∂ÑÌï† ÎßàÏä§ÌÅ¨Ïùò ÌíàÏßà ÌèâÍ∞Ä
        if output.dim() > 1:
            # 2D Ïù¥ÏÉÅÏù∏ Í≤ΩÏö∞ ÌèâÍ∑†Í∞í ÏÇ¨Ïö©
            output_flat = output.mean(dim=0) if output.dim() > 1 else output
        else:
            output_flat = output
        
        # Î∂ÑÌï† ÌíàÏßà (entropy Í∏∞Î∞ò)
        if output_flat.numel() > 1:
            probs = F.softmax(output_flat, dim=0)
            entropy = -torch.sum(probs * torch.log(probs + 1e-8))
            max_entropy = torch.log(torch.tensor(float(output_flat.numel())))
            quality_score = float(entropy / max_entropy)
        else:
            quality_score = 0.0
        
        return quality_score
    
    def _calculate_boundary_accuracy(self, output: torch.Tensor) -> float:
        """Í≤ΩÍ≥Ñ Ï†ïÌôïÎèÑ Í≥ÑÏÇ∞"""
        if output.dim() == 0:
            return 0.0
        
        # Í≤ΩÍ≥ÑÏùò ÏÑ†Î™ÖÎèÑ Í≥ÑÏÇ∞
        if output.dim() > 2:
            # 2D Ïù¥ÎØ∏ÏßÄÏùò Í≤ΩÏö∞ Í≤ΩÍ≥Ñ Í≤ÄÏ∂ú
            batch_size = output.size(0)
            boundary_scores = []
            
            for b in range(batch_size):
                # Sobel ÌïÑÌÑ∞Î•º ÏÇ¨Ïö©Ìïú Í≤ΩÍ≥Ñ Í≤ÄÏ∂ú
                if output.size(1) > 1:  # Ï±ÑÎÑêÏù¥ ÏûàÎäî Í≤ΩÏö∞
                    img = output[b].mean(dim=0)  # Ï±ÑÎÑê ÌèâÍ∑†
                else:
                    img = output[b]
                
                # Í≤ΩÍ≥Ñ Í∞ïÎèÑ Í≥ÑÏÇ∞
                if img.dim() == 2:
                    # 2D ÌÖêÏÑúÎ•º numpyÎ°ú Î≥ÄÌôò
                    img_np = img.detach().cpu().numpy()
                    
                    # Sobel ÌïÑÌÑ∞ Ï†ÅÏö©
                    sobel_x = cv2.Sobel(img_np, cv2.CV_64F, 1, 0, ksize=3)
                    sobel_y = cv2.Sobel(img_np, cv2.CV_64F, 0, 1, ksize=3)
                    
                    # Í≤ΩÍ≥Ñ Í∞ïÎèÑ
                    boundary_magnitude = np.sqrt(sobel_x**2 + sobel_y**2)
                    boundary_score = float(np.mean(boundary_magnitude))
                    boundary_scores.append(boundary_score)
            
            return float(np.mean(boundary_scores)) if boundary_scores else 0.0
        else:
            return 0.0
    
    def get_quality_metrics(self) -> Dict[str, float]:
        """ÌíàÏßà Î©îÌä∏Î¶≠ Î∞òÌôò"""
        return self.quality_metrics.copy()
    
    def update_ensemble_weights(self, new_weights: torch.Tensor):
        """ÏïôÏÉÅÎ∏î Í∞ÄÏ§ëÏπò ÏóÖÎç∞Ïù¥Ìä∏"""
        if new_weights.shape == self.ensemble_weights.shape:
            with torch.no_grad():
                self.ensemble_weights.copy_(new_weights)
            self.logger.info("‚úÖ ÏïôÏÉÅÎ∏î Í∞ÄÏ§ëÏπò ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å")
        else:
            self.logger.warning(f"Í∞ÄÏ§ëÏπò Ï∞®Ïõê Î∂àÏùºÏπò: {new_weights.shape} vs {self.ensemble_weights.shape}")
    
    def get_ensemble_info(self) -> Dict[str, Union[str, int, float]]:
        """ÏïôÏÉÅÎ∏î ÏãúÏä§ÌÖú Ï†ïÎ≥¥ Î∞òÌôò"""
        return {
            "method": self.config.method,
            "num_models": self.config.max_models,
            "device": str(self.device),
            "quality_threshold": self.config.quality_threshold,
            "confidence_threshold": self.config.confidence_threshold,
            "memory_efficient": self.config.memory_efficient,
            "current_weights": self.ensemble_weights.detach().cpu().numpy().tolist()
        }

# ÏïôÏÉÅÎ∏î ÏãúÏä§ÌÖú Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Ìï®Ïàò
def create_cloth_segmentation_ensemble(config: EnsembleConfig = None) -> ClothSegmentationEnsembleSystem:
    """Cloth Segmentation ÏïôÏÉÅÎ∏î ÏãúÏä§ÌÖú ÏÉùÏÑ±"""
    return ClothSegmentationEnsembleSystem(config)

# Í∏∞Î≥∏ ÏÑ§Ï†ïÏúºÎ°ú ÏïôÏÉÅÎ∏î ÏãúÏä§ÌÖú ÏÉùÏÑ±
def create_default_ensemble() -> ClothSegmentationEnsembleSystem:
    """Í∏∞Î≥∏ ÏÑ§Ï†ïÏúºÎ°ú ÏïôÏÉÅÎ∏î ÏãúÏä§ÌÖú ÏÉùÏÑ±"""
    config = EnsembleConfig(
        method="quality_weighted",
        quality_threshold=0.7,
        confidence_threshold=0.5,
        max_models=8,
        use_mps=True,
        memory_efficient=True
    )
    return ClothSegmentationEnsembleSystem(config)

# ÎèôÍ∏∞ ÏïôÏÉÅÎ∏î Ïã§Ìñâ Ìï®Ïàò Ï∂îÍ∞Ä (import Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥)
def _run_hybrid_ensemble_sync(model_outputs: List[torch.Tensor], 
                              confidences: List[float] = None,
                              quality_scores: List[float] = None,
                              config: EnsembleConfig = None) -> torch.Tensor:
    """
    ÎèôÍ∏∞ ÏïôÏÉÅÎ∏î Ïã§Ìñâ Ìï®Ïàò (import Ìò∏ÌôòÏÑ±)
    
    Args:
        model_outputs: Í∞Å Î™®Îç∏Ïùò Ï∂úÎ†• (List[torch.Tensor])
        confidences: Í∞Å Î™®Îç∏Ïùò Ïã†Î¢∞ÎèÑ (List[float])
        quality_scores: Í∞Å Î™®Îç∏Ïùò ÌíàÏßà Ï†êÏàò (List[float])
        config: ÏïôÏÉÅÎ∏î ÏÑ§Ï†ï
    
    Returns:
        ÏïôÏÉÅÎ∏îÎêú ÏùòÎ•ò Î∂ÑÌï† Í≤∞Í≥º
    """
    try:
        # Í∏∞Î≥∏ ÏÑ§Ï†ï ÏÇ¨Ïö©
        if config is None:
            config = EnsembleConfig()
        
        # ÏïôÏÉÅÎ∏î ÏãúÏä§ÌÖú ÏÉùÏÑ±
        ensemble = ClothSegmentationEnsembleSystem(config)
        
        # ÏïôÏÉÅÎ∏î Ïã§Ìñâ
        result = ensemble(model_outputs, confidences, quality_scores)
        
        return result
        
    except Exception as e:
        logger.error(f"ÎèôÍ∏∞ ÏïôÏÉÅÎ∏î Ïã§Ìñâ Ïã§Ìå®: {e}")
        # Ïò§Î•ò Ïãú Ï≤´ Î≤àÏß∏ Ï∂úÎ†• Î∞òÌôò
        if model_outputs:
            return model_outputs[0]
        else:
            # Îπà Ï∂úÎ†• ÏÉùÏÑ±
            if TORCH_AVAILABLE:
                return torch.zeros(1, 1, 256, 256)
            else:
                return None

# _combine_ensemble_results Ìï®Ïàò Ï∂îÍ∞Ä (import Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥)
def _combine_ensemble_results(model_outputs: List[torch.Tensor], 
                             confidences: List[float] = None,
                             quality_scores: List[float] = None,
                             method: str = "quality_weighted") -> torch.Tensor:
    """
    ÏïôÏÉÅÎ∏î Í≤∞Í≥º Í≤∞Ìï© Ìï®Ïàò (import Ìò∏ÌôòÏÑ±)
    
    Args:
        model_outputs: Í∞Å Î™®Îç∏Ïùò Ï∂úÎ†• (List[torch.Tensor])
        confidences: Í∞Å Î™®Îç∏Ïùò Ïã†Î¢∞ÎèÑ (List[float])
        quality_scores: Í∞Å Î™®Îç∏Ïùò ÌíàÏßà Ï†êÏàò (List[float])
        method: ÏïôÏÉÅÎ∏î Î∞©Î≤ï
    
    Returns:
        Í≤∞Ìï©Îêú Í≤∞Í≥º
    """
    try:
        if not model_outputs:
            raise ValueError("Î™®Îç∏ Ï∂úÎ†•Ïù¥ ÎπÑÏñ¥ÏûàÏäµÎãàÎã§")
        
        # Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
        if confidences is None:
            confidences = [1.0] * len(model_outputs)
        if quality_scores is None:
            quality_scores = [1.0] * len(model_outputs)
        
        # Î™®Îì† Ï∂úÎ†•ÏùÑ ÎèôÏùºÌïú ÌòïÌÉúÎ°ú Î≥ÄÌôò
        outputs = []
        for output in model_outputs:
            if TORCH_AVAILABLE and isinstance(output, torch.Tensor):
                outputs.append(output.detach().cpu().numpy())
            else:
                outputs.append(np.array(output))
        
        # ÏïôÏÉÅÎ∏î Î∞©Î≤ïÏóê Îî∞Î•∏ Í≤∞Ìï©
        if method == "simple_average":
            # Îã®Ïàú ÌèâÍ∑†
            combined = np.mean(outputs, axis=0)
        elif method == "weighted_average":
            # Í∞ÄÏ§ë ÌèâÍ∑† (Ïã†Î¢∞ÎèÑ Í∏∞Î∞ò)
            weights = np.array(confidences)
            weights = weights / np.sum(weights)  # Ï†ïÍ∑úÌôî
            combined = np.average(outputs, axis=0, weights=weights)
        elif method == "quality_weighted":
            # ÌíàÏßà Í∏∞Î∞ò Í∞ÄÏ§ë ÌèâÍ∑†
            weights = np.array(quality_scores)
            weights = weights / np.sum(weights)  # Ï†ïÍ∑úÌôî
            combined = np.average(outputs, axis=0, weights=weights)
        else:
            # Í∏∞Î≥∏Í∞í: Îã®Ïàú ÌèâÍ∑†
            combined = np.mean(outputs, axis=0)
        
        # torch ÌÖêÏÑúÎ°ú Î≥ÄÌôò (Í∞ÄÎä•Ìïú Í≤ΩÏö∞)
        if TORCH_AVAILABLE:
            return torch.from_numpy(combined).float()
        else:
            return combined
            
    except Exception as e:
        logger.error(f"ÏïôÏÉÅÎ∏î Í≤∞Í≥º Í≤∞Ìï© Ïã§Ìå®: {e}")
        # Ïò§Î•ò Ïãú Ï≤´ Î≤àÏß∏ Ï∂úÎ†• Î∞òÌôò
        if model_outputs:
            if TORCH_AVAILABLE and isinstance(model_outputs[0], torch.Tensor):
                return model_outputs[0]
            else:
                return np.array(model_outputs[0])
        else:
            # Îπà Ï∂úÎ†• ÏÉùÏÑ±
            if TORCH_AVAILABLE:
                return torch.zeros(1, 1, 256, 256)
            else:
                return np.zeros((1, 1, 256, 256))

# _calculate_adaptive_threshold Ìï®Ïàò Ï∂îÍ∞Ä (import Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥)
def _calculate_adaptive_threshold(confidences: List[float], 
                                quality_scores: List[float] = None,
                                base_threshold: float = 0.5) -> float:
    """
    Ï†ÅÏùëÌòï ÏûÑÍ≥ÑÍ∞í Í≥ÑÏÇ∞ Ìï®Ïàò (import Ìò∏ÌôòÏÑ±)
    
    Args:
        confidences: Í∞Å Î™®Îç∏Ïùò Ïã†Î¢∞ÎèÑ Î¶¨Ïä§Ìä∏
        quality_scores: Í∞Å Î™®Îç∏Ïùò ÌíàÏßà Ï†êÏàò Î¶¨Ïä§Ìä∏
        base_threshold: Í∏∞Î≥∏ ÏûÑÍ≥ÑÍ∞í
    
    Returns:
        Í≥ÑÏÇ∞Îêú Ï†ÅÏùëÌòï ÏûÑÍ≥ÑÍ∞í
    """
    try:
        if not confidences:
            return base_threshold
        
        # Ïã†Î¢∞ÎèÑ Í∏∞Î∞ò ÏûÑÍ≥ÑÍ∞í
        confidence_threshold = np.mean(confidences) * 0.8
        
        # ÌíàÏßà Ï†êÏàò Í∏∞Î∞ò ÏûÑÍ≥ÑÍ∞í (ÏûàÎäî Í≤ΩÏö∞)
        if quality_scores and len(quality_scores) == len(confidences):
            quality_threshold = np.mean(quality_scores) * 0.7
            # Ïã†Î¢∞ÎèÑÏôÄ ÌíàÏßà Ï†êÏàòÏùò Í∞ÄÏ§ë ÌèâÍ∑†
            adaptive_threshold = 0.6 * confidence_threshold + 0.4 * quality_threshold
        else:
            adaptive_threshold = confidence_threshold
        
        # Í∏∞Î≥∏ ÏûÑÍ≥ÑÍ∞íÍ≥º ÎπÑÍµêÌïòÏó¨ Ï†ÅÏ†àÌïú Î≤îÏúÑ ÎÇ¥Î°ú Ï†úÌïú
        final_threshold = np.clip(adaptive_threshold, base_threshold * 0.5, base_threshold * 1.5)
        
        return float(final_threshold)
        
    except Exception as e:
        logger.warning(f"Ï†ÅÏùëÌòï ÏûÑÍ≥ÑÍ∞í Í≥ÑÏÇ∞ Ïã§Ìå®: {e}, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
        return base_threshold

# _apply_ensemble_postprocessing Ìï®Ïàò Ï∂îÍ∞Ä (import Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥)
def _apply_ensemble_postprocessing(ensemble_output: torch.Tensor,
                                 individual_outputs: List[torch.Tensor],
                                 confidences: List[float] = None,
                                 method: str = "quality_weighted") -> torch.Tensor:
    """
    ÏïôÏÉÅÎ∏î ÌõÑÏ≤òÎ¶¨ Ï†ÅÏö© Ìï®Ïàò (import Ìò∏ÌôòÏÑ±)
    
    Args:
        ensemble_output: ÏïôÏÉÅÎ∏î Í≤∞Í≥º
        individual_outputs: Í∞úÎ≥Ñ Î™®Îç∏ Ï∂úÎ†•
        confidences: Í∞Å Î™®Îç∏Ïùò Ïã†Î¢∞ÎèÑ
        method: ÌõÑÏ≤òÎ¶¨ Î∞©Î≤ï
    
    Returns:
        ÌõÑÏ≤òÎ¶¨Îêú Í≤∞Í≥º
    """
    try:
        if not individual_outputs:
            return ensemble_output
        
        # Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
        if confidences is None:
            confidences = [1.0] * len(individual_outputs)
        
        # ÌõÑÏ≤òÎ¶¨ Î∞©Î≤ïÏóê Îî∞Î•∏ Ï≤òÎ¶¨
        if method == "confidence_weighted":
            # Ïã†Î¢∞ÎèÑ Í∏∞Î∞ò Í∞ÄÏ§ë ÌèâÍ∑†
            weights = np.array(confidences)
            weights = weights / np.sum(weights)  # Ï†ïÍ∑úÌôî
            
            # Î™®Îì† Ï∂úÎ†•ÏùÑ ÎèôÏùºÌïú ÌòïÌÉúÎ°ú Î≥ÄÌôò
            outputs = []
            for output in individual_outputs:
                if TORCH_AVAILABLE and isinstance(output, torch.Tensor):
                    outputs.append(output.detach().cpu().numpy())
                else:
                    outputs.append(np.array(output))
            
            # Í∞ÄÏ§ë ÌèâÍ∑† Í≥ÑÏÇ∞
            weighted_output = np.average(outputs, axis=0, weights=weights)
            
            # torch ÌÖêÏÑúÎ°ú Î≥ÄÌôò (Í∞ÄÎä•Ìïú Í≤ΩÏö∞)
            if TORCH_AVAILABLE:
                return torch.from_numpy(weighted_output).float()
            else:
                return weighted_output
                
        elif method == "quality_enhancement":
            # ÌíàÏßà Ìñ•ÏÉÅ ÌõÑÏ≤òÎ¶¨
            if TORCH_AVAILABLE and isinstance(ensemble_output, torch.Tensor):
                # Í∞ÑÎã®Ìïú ÌíàÏßà Ìñ•ÏÉÅ: ÎÖ∏Ïù¥Ï¶à Ï†úÍ±∞
                enhanced = ensemble_output.clone()
                # ÏûÑÍ≥ÑÍ∞í Í∏∞Î∞ò ÌïÑÌÑ∞ÎßÅ
                threshold = 0.1
                enhanced[enhanced < threshold] = 0
                return enhanced
            else:
                # numpy Î∞∞Ïó¥Ïù∏ Í≤ΩÏö∞
                enhanced = np.array(ensemble_output).copy()
                threshold = 0.1
                enhanced[enhanced < threshold] = 0
                return enhanced
                
        else:
            # Í∏∞Î≥∏Í∞í: ÏõêÎ≥∏ ÏïôÏÉÅÎ∏î Ï∂úÎ†• Î∞òÌôò
            return ensemble_output
            
    except Exception as e:
        logger.error(f"ÏïôÏÉÅÎ∏î ÌõÑÏ≤òÎ¶¨ Ï†ÅÏö© Ïã§Ìå®: {e}")
        # Ïò§Î•ò Ïãú ÏõêÎ≥∏ Ï∂úÎ†• Î∞òÌôò
        return ensemble_output

if __name__ == "__main__":
    # ÌÖåÏä§Ìä∏ ÏΩîÎìú
    logging.basicConfig(level=logging.INFO)
    
    # ÏïôÏÉÅÎ∏î ÏãúÏä§ÌÖú ÏÉùÏÑ±
    ensemble = create_default_ensemble()
    
    # ÌÖåÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    batch_size, channels, height, width = 2, 1, 256, 256
    test_outputs = [
        torch.randn(batch_size, channels, height, width) for _ in range(4)
    ]
    
    # ÏïôÏÉÅÎ∏î ÏàòÌñâ
    result = ensemble(test_outputs)
    print(f"ÏïôÏÉÅÎ∏î Í≤∞Í≥º ÌòïÌÉú: {result.shape}")
    print(f"ÌíàÏßà Î©îÌä∏Î¶≠: {ensemble.get_quality_metrics()}")
    print(f"ÏïôÏÉÅÎ∏î Ï†ïÎ≥¥: {ensemble.get_ensemble_info()}")
