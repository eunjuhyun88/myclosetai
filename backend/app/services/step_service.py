# backend/app/services/step_service.py
"""
üî• MyCloset AI Step Service v15.0 - Interface Layer (ÏôÑÏ†Ñ ÏàòÏ†ï)
================================================================

‚úÖ Ïã§Ï†ú Step ÌååÏùºÎì§Í≥º 100% ÏôÑÎ≤Ω Ïó∞Îèô
‚úÖ BaseStepMixin + ModelLoader ÏôÑÏ†Ñ ÌÜµÌï©
‚úÖ ÌÜµÌï© Step Îß§ÌïëÏúºÎ°ú ÏùºÍ¥ÄÏÑ± ÌôïÎ≥¥
‚úÖ Í∏∞Ï°¥ API Ìï®ÏàòÎ™Ö 100% Ïú†ÏßÄ
‚úÖ Interface-Implementation Pattern ÏôÑÏ†Ñ Ï†ÅÏö©
‚úÖ ÏàúÌôòÏ∞∏Ï°∞ ÏôÑÏ†Ñ Ìï¥Í≤∞
‚úÖ M3 Max 128GB ÏµúÏ†ÅÌôî
‚úÖ conda ÌôòÍ≤Ω Ïö∞ÏÑ† ÏßÄÏõê
‚úÖ ÏóêÎü¨ Ï≤òÎ¶¨ Î∞è Ìè¥Î∞± ÏãúÏä§ÌÖú

Íµ¨Ï°∞: step_routes.py ‚Üí step_service.py ‚Üí step_implementations.py ‚Üí BaseStepMixin + AI Steps

Author: MyCloset AI Team
Date: 2025-07-21
Version: 15.0 (Interface Layer Complete)
"""

import logging
import asyncio
import time
import threading
import uuid
import traceback
from typing import Dict, Any, Optional, List, Union, Tuple, TYPE_CHECKING
from datetime import datetime
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum

# ÏïàÏ†ÑÌïú ÌÉÄÏûÖ ÌûåÌåÖ
if TYPE_CHECKING:
    from fastapi import UploadFile

# ==============================================
# üî• ÌïÑÏàò Import (ÏàúÌôòÏ∞∏Ï°∞ Î∞©ÏßÄ)
# ==============================================

# FastAPI imports (ÏÑ†ÌÉùÏ†Å)
try:
    from fastapi import UploadFile
    FASTAPI_AVAILABLE = True
except ImportError:
    FASTAPI_AVAILABLE = False
    class UploadFile:
        pass

# Ïä§ÌÇ§Îßà import
try:
    from ..models.schemas import BodyMeasurements
    SCHEMAS_AVAILABLE = True
except ImportError:
    SCHEMAS_AVAILABLE = False
    
    @dataclass
    class BodyMeasurements:
        height: float
        weight: float
        chest: Optional[float] = None
        waist: Optional[float] = None
        hips: Optional[float] = None

# ==============================================
# üî• ÌÜµÌï© Step Îß§Ìïë (ÏôÑÏ†Ñ ÌÜµÏùº)
# ==============================================

class StepType(Enum):
    """Step ÌÉÄÏûÖ Î∂ÑÎ•ò"""
    VALIDATION = "validation"     # 1-2Îã®Í≥Ñ: Í≤ÄÏ¶ù
    AI_PROCESSING = "ai_processing"  # 3-10Îã®Í≥Ñ: AI Ï≤òÎ¶¨
    PIPELINE = "pipeline"        # 0Îã®Í≥Ñ: Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏

@dataclass
class UnifiedStepSignature:
    """ÌÜµÌï© Step ÏãúÍ∑∏ÎãàÏ≤ò (Ïã§Ï†ú Step ÌååÏùºÎì§Í≥º 100% ÏùºÏπò)"""
    step_id: int
    step_class_name: str
    service_class_name: str
    step_type: StepType
    required_args: List[str]
    required_kwargs: List[str]
    optional_kwargs: List[str]
    ai_models_needed: List[str]
    description: str

# üî• Ïã§Ï†ú Step ÌååÏùºÎì§Í≥º ÏôÑÏ†Ñ ÏùºÏπòÌïòÎäî ÏãúÍ∑∏ÎãàÏ≤ò Îß§Ìïë
UNIFIED_STEP_MAPPING = {
    1: UnifiedStepSignature(
        step_id=1,
        step_class_name="UploadValidationService",
        service_class_name="UploadValidationService",
        step_type=StepType.VALIDATION,
        required_args=["person_image", "clothing_image"],
        required_kwargs=[],
        optional_kwargs=["session_id"],
        ai_models_needed=[],
        description="Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Í≤ÄÏ¶ù"
    ),
    
    2: UnifiedStepSignature(
        step_id=2,
        step_class_name="MeasurementsValidationService",
        service_class_name="MeasurementsValidationService",
        step_type=StepType.VALIDATION,
        required_args=["measurements"],
        required_kwargs=[],
        optional_kwargs=["session_id"],
        ai_models_needed=[],
        description="Ïã†Ï≤¥ Ï∏°Ï†ïÍ∞í Í≤ÄÏ¶ù"
    ),
    
    # AI Ï≤òÎ¶¨ Îã®Í≥ÑÎì§ (Ïã§Ï†ú Step ÌÅ¥ÎûòÏä§ÏôÄ Ïó∞Îèô)
    3: UnifiedStepSignature(
        step_id=3,
        step_class_name="HumanParsingStep",
        service_class_name="HumanParsingService",
        step_type=StepType.AI_PROCESSING,
        required_args=["person_image"],
        required_kwargs=[],
        optional_kwargs=["enhance_quality", "session_id"],
        ai_models_needed=["human_parsing_model", "segmentation_model"],
        description="AI Í∏∞Î∞ò Ïù∏Í∞Ñ ÌååÏã± - ÏÇ¨Îûå Ïù¥ÎØ∏ÏßÄÏóêÏÑú Ïã†Ï≤¥ Î∂ÄÏúÑ Î∂ÑÌï†"
    ),
    
    4: UnifiedStepSignature(
        step_id=4,
        step_class_name="PoseEstimationStep", 
        service_class_name="PoseEstimationService",
        step_type=StepType.AI_PROCESSING,
        required_args=["image"],
        required_kwargs=["clothing_type"],
        optional_kwargs=["detection_confidence", "session_id"],
        ai_models_needed=["pose_estimation_model", "keypoint_detector"],
        description="AI Í∏∞Î∞ò Ìè¨Ï¶à Ï∂îÏ†ï - ÏÇ¨ÎûåÏùò Ìè¨Ï¶àÏôÄ Í¥ÄÏ†à ÏúÑÏπò Í≤ÄÏ∂ú"
    ),
    
    5: UnifiedStepSignature(
        step_id=5,
        step_class_name="ClothSegmentationStep",
        service_class_name="ClothingAnalysisService", 
        step_type=StepType.AI_PROCESSING,
        required_args=["image"],
        required_kwargs=["clothing_type", "quality_level"],
        optional_kwargs=["session_id"],
        ai_models_needed=["cloth_segmentation_model", "texture_analyzer"],
        description="AI Í∏∞Î∞ò ÏùòÎ•ò Î∂ÑÌï† - ÏùòÎ•ò Ïù¥ÎØ∏ÏßÄÏóêÏÑú ÏùòÎ•ò ÏòÅÏó≠ Î∂ÑÌï†"
    ),
    
    6: UnifiedStepSignature(
        step_id=6,
        step_class_name="GeometricMatchingStep",
        service_class_name="GeometricMatchingService",
        step_type=StepType.AI_PROCESSING,
        required_args=["person_image", "clothing_image"],
        required_kwargs=[],
        optional_kwargs=["pose_keypoints", "body_mask", "clothing_mask", "matching_precision", "session_id"],
        ai_models_needed=["geometric_matching_model", "tps_network", "feature_extractor"],
        description="AI Í∏∞Î∞ò Í∏∞ÌïòÌïôÏ†Å Îß§Ïπ≠ - ÏÇ¨ÎûåÍ≥º ÏùòÎ•ò Í∞ÑÏùò AI Îß§Ïπ≠"
    ),
    
    7: UnifiedStepSignature(
        step_id=7,
        step_class_name="ClothWarpingStep",
        service_class_name="ClothWarpingService",
        step_type=StepType.AI_PROCESSING,
        required_args=["cloth_image", "person_image"],
        required_kwargs=[],
        optional_kwargs=["cloth_mask", "fabric_type", "clothing_type", "session_id"],
        ai_models_needed=["cloth_warping_model", "deformation_network"],
        description="AI Í∏∞Î∞ò ÏùòÎ•ò ÏõåÌïë - AIÎ°ú ÏùòÎ•òÎ•º ÏÇ¨Îûå Ï≤¥ÌòïÏóê ÎßûÍ≤å Î≥ÄÌòï"
    ),
    
    8: UnifiedStepSignature(
        step_id=8,
        step_class_name="VirtualFittingStep",
        service_class_name="VirtualFittingService",
        step_type=StepType.AI_PROCESSING,
        required_args=["person_image", "cloth_image"],
        required_kwargs=[],
        optional_kwargs=["pose_data", "cloth_mask", "fitting_quality", "session_id"],
        ai_models_needed=["virtual_fitting_model", "rendering_network", "style_transfer_model"],
        description="AI Í∏∞Î∞ò Í∞ÄÏÉÅ ÌîºÌåÖ - AIÎ°ú ÏÇ¨ÎûåÏóêÍ≤å ÏùòÎ•òÎ•º Í∞ÄÏÉÅÏúºÎ°ú Ï∞©Ïö©"
    ),
    
    9: UnifiedStepSignature(
        step_id=9,
        step_class_name="PostProcessingStep",
        service_class_name="PostProcessingService",
        step_type=StepType.AI_PROCESSING,
        required_args=["fitted_image"],
        required_kwargs=[],
        optional_kwargs=["enhancement_level", "session_id"],
        ai_models_needed=["post_processing_model", "enhancement_network"],
        description="AI Í∏∞Î∞ò ÌõÑÏ≤òÎ¶¨ - AIÎ°ú ÌîºÌåÖ Í≤∞Í≥º Ïù¥ÎØ∏ÏßÄ ÌíàÏßà Ìñ•ÏÉÅ"
    ),
    
    10: UnifiedStepSignature(
        step_id=10,
        step_class_name="QualityAssessmentStep",
        service_class_name="ResultAnalysisService",
        step_type=StepType.AI_PROCESSING,
        required_args=["final_image"],
        required_kwargs=[],
        optional_kwargs=["analysis_depth", "session_id"],
        ai_models_needed=["quality_assessment_model", "evaluation_network"],
        description="AI Í∏∞Î∞ò ÌíàÏßà ÌèâÍ∞Ä - AIÎ°ú ÏµúÏ¢Ö Í≤∞Í≥ºÏùò ÌíàÏßà Ï†êÏàò Î∞è Î∂ÑÏÑù"
    ),
    
    0: UnifiedStepSignature(
        step_id=0,
        step_class_name="CompletePipelineService",
        service_class_name="CompletePipelineService",
        step_type=StepType.PIPELINE,
        required_args=["person_image", "clothing_image", "measurements"],
        required_kwargs=[],
        optional_kwargs=[],
        ai_models_needed=[],
        description="ÏôÑÏ†ÑÌïú AI ÌååÏù¥ÌîÑÎùºÏù∏ Ï≤òÎ¶¨"
    )
}

# ==============================================
# üî• ÏÑúÎπÑÏä§ ÏÉÅÌÉú Î∞è Î©îÌä∏Î¶≠
# ==============================================

class ServiceStatus(Enum):
    """ÏÑúÎπÑÏä§ ÏÉÅÌÉú"""
    INACTIVE = "inactive"
    INITIALIZING = "initializing"
    ACTIVE = "active"
    ERROR = "error"

@dataclass
class ServiceMetrics:
    """ÏÑúÎπÑÏä§ Î©îÌä∏Î¶≠"""
    total_requests: int = 0
    successful_requests: int = 0
    failed_requests: int = 0
    average_processing_time: float = 0.0
    last_request_time: Optional[datetime] = None
    service_start_time: datetime = datetime.now()

# ==============================================
# üî• Ï∂îÏÉÅ ÏÑúÎπÑÏä§ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
# ==============================================

class StepServiceInterface(ABC):
    """Step ÏÑúÎπÑÏä§ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ (Î™®Îì† ÏÑúÎπÑÏä§Í∞Ä Îî∞Î•º Í≥ÑÏïΩ)"""
    
    def __init__(self, step_name: str, step_id: int):
        self.step_name = step_name
        self.step_id = step_id
        self.logger = logging.getLogger(f"services.{step_name}")
        self.status = ServiceStatus.INACTIVE
        self.metrics = ServiceMetrics()
    
    @abstractmethod
    async def process(self, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """ÏÑúÎπÑÏä§ Ï≤òÎ¶¨ (Íµ¨ÌòÑÏ≤¥ÏóêÏÑú Ï†ïÏùò)"""
        pass
    
    @abstractmethod
    async def initialize(self) -> bool:
        """ÏÑúÎπÑÏä§ Ï¥àÍ∏∞Ìôî (Íµ¨ÌòÑÏ≤¥ÏóêÏÑú Ï†ïÏùò)"""
        pass
    
    @abstractmethod
    async def cleanup(self):
        """ÏÑúÎπÑÏä§ Ï†ïÎ¶¨ (Íµ¨ÌòÑÏ≤¥ÏóêÏÑú Ï†ïÏùò)"""
        pass
    
    def _create_success_result(self, data: Dict, processing_time: float = 0.0) -> Dict[str, Any]:
        """ÏÑ±Í≥µ Í≤∞Í≥º ÏÉùÏÑ±"""
        return {
            "success": True,
            "step_name": self.step_name,
            "step_id": self.step_id,
            "processing_time": processing_time,
            "timestamp": datetime.now().isoformat(),
            "interface_layer": True,
            **data
        }
    
    def _create_error_result(self, error: str, processing_time: float = 0.0) -> Dict[str, Any]:
        """ÏóêÎü¨ Í≤∞Í≥º ÏÉùÏÑ±"""
        return {
            "success": False,
            "error": error,
            "step_name": self.step_name,
            "step_id": self.step_id,
            "processing_time": processing_time,
            "timestamp": datetime.now().isoformat(),
            "interface_layer": True
        }
    
    def get_service_metrics(self) -> Dict[str, Any]:
        """ÏÑúÎπÑÏä§ Î©îÌä∏Î¶≠ Î∞òÌôò"""
        return {
            "service_name": self.step_name,
            "step_id": self.step_id,
            "status": self.status.value,
            "total_requests": self.metrics.total_requests,
            "successful_requests": self.metrics.successful_requests,
            "failed_requests": self.metrics.failed_requests,
            "success_rate": self.metrics.successful_requests / self.metrics.total_requests if self.metrics.total_requests > 0 else 0,
            "average_processing_time": self.metrics.average_processing_time,
            "last_request_time": self.metrics.last_request_time.isoformat() if self.metrics.last_request_time else None,
            "service_uptime": (datetime.now() - self.metrics.service_start_time).total_seconds()
        }

# ==============================================
# üî• Íµ¨ÌòÑÏ≤¥ Í¥ÄÎ¶¨Ïûê (step_implementations.pyÎ°ú ÏúÑÏûÑ)
# ==============================================

class StepImplementationManager:
    """Íµ¨ÌòÑÏ≤¥ ÌÜµÌï© Í¥ÄÎ¶¨Ïûê - step_implementations.pyÎ°ú ÏúÑÏûÑ"""
    
    def __init__(self):
        self.logger = logging.getLogger(f"{__name__}.StepImplementationManager")
        self.services: Dict[int, StepServiceInterface] = {}
        self._lock = threading.RLock()
        
        # Íµ¨ÌòÑÏ≤¥ Î™®Îìà ÏßÄÏó∞ Î°úÎìú
        self._implementation_module = None
        self._load_implementation_module()
    
    def _load_implementation_module(self):
        """Íµ¨ÌòÑÏ≤¥ Î™®Îìà ÏßÄÏó∞ Î°úÎìú"""
        try:
            from . import step_implementations
            self._implementation_module = step_implementations
            self.logger.info("‚úÖ Step Íµ¨ÌòÑÏ≤¥ Î™®Îìà Î°úÎìú ÏÑ±Í≥µ")
        except ImportError as e:
            self.logger.warning(f"‚ö†Ô∏è Step Íµ¨ÌòÑÏ≤¥ Î™®Îìà Î°úÎìú Ïã§Ìå®: {e} - Ìè¥Î∞± Î™®ÎìúÎ°ú ÎèôÏûë")
            self._implementation_module = None
    
    async def get_service(self, step_id: int) -> StepServiceInterface:
        """ÏÑúÎπÑÏä§ Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò (Ï∫êÏã±)"""
        with self._lock:
            if step_id not in self.services:
                if self._implementation_module:
                    # Ïã§Ï†ú Íµ¨ÌòÑÏ≤¥ ÏÇ¨Ïö©
                    service = self._implementation_module.create_service(step_id)
                else:
                    # Ìè¥Î∞±: Í∏∞Î≥∏ Íµ¨ÌòÑÏ≤¥ ÏÇ¨Ïö©
                    service = self._create_fallback_service(step_id)
                
                if service:
                    await service.initialize()
                    self.services[step_id] = service
                    self.logger.info(f"‚úÖ Step {step_id} ÏÑúÎπÑÏä§ ÏÉùÏÑ± ÏôÑÎ£å")
                else:
                    raise ValueError(f"Step {step_id} ÏÑúÎπÑÏä§ ÏÉùÏÑ± Ïã§Ìå®")
        
        return self.services[step_id]
    
    def _create_fallback_service(self, step_id: int) -> StepServiceInterface:
        """Ìè¥Î∞± ÏÑúÎπÑÏä§ ÏÉùÏÑ±"""
        
        class FallbackService(StepServiceInterface):
            """Ìè¥Î∞± ÏÑúÎπÑÏä§ Íµ¨ÌòÑ"""
            
            def __init__(self, step_id: int):
                signature = UNIFIED_STEP_MAPPING.get(step_id)
                step_name = signature.service_class_name if signature else f"FallbackStep{step_id}"
                super().__init__(step_name, step_id)
            
            async def initialize(self) -> bool:
                self.status = ServiceStatus.ACTIVE
                return True
            
            async def process(self, inputs: Dict[str, Any]) -> Dict[str, Any]:
                await asyncio.sleep(0.1)  # ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏßÄÏó∞
                return self._create_success_result({
                    "message": f"Step {self.step_id} Ï≤òÎ¶¨ ÏôÑÎ£å (Ìè¥Î∞± Î™®Îìú)",
                    "confidence": 0.7,
                    "fallback_mode": True,
                    "details": inputs
                })
            
            async def cleanup(self):
                self.status = ServiceStatus.INACTIVE
        
        return FallbackService(step_id)
    
    # ==============================================
    # Step Ï≤òÎ¶¨ Î©îÏÑúÎìúÎì§ (Íµ¨ÌòÑÏ≤¥Î°ú ÏúÑÏûÑ)
    # ==============================================
    
    async def execute_step(self, step_id: int, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """Step Ïã§Ìñâ (Ïã§Ï†ú Íµ¨ÌòÑÏ≤¥ Ìò∏Ï∂ú)"""
        try:
            service = await self.get_service(step_id)
            return await service.process(inputs)
        except Exception as e:
            self.logger.error(f"‚ùå Step {step_id} Ïã§Ìñâ Ïã§Ìå®: {e}")
            return {
                "success": False,
                "error": str(e),
                "step_id": step_id,
                "implementation_error": True,
                "timestamp": datetime.now().isoformat()
            }
    
    async def cleanup_all(self):
        """Î™®Îì† ÏÑúÎπÑÏä§ Ï†ïÎ¶¨"""
        with self._lock:
            for step_id, service in self.services.items():
                try:
                    await service.cleanup()
                    self.logger.info(f"‚úÖ Step {step_id} ÏÑúÎπÑÏä§ Ï†ïÎ¶¨ ÏôÑÎ£å")
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è Step {step_id} ÏÑúÎπÑÏä§ Ï†ïÎ¶¨ Ïã§Ìå®: {e}")
            
            self.services.clear()
            self.logger.info("‚úÖ Î™®Îì† Íµ¨ÌòÑÏ≤¥ ÏÑúÎπÑÏä§ Ï†ïÎ¶¨ ÏôÑÎ£å")

# ==============================================
# üî• Î©îÏù∏ ÏÑúÎπÑÏä§ Îß§ÎãàÏ†Ä (API ÏßÑÏûÖÏ†ê)
# ==============================================

class UnifiedStepServiceManager:
    """Î©îÏù∏ ÏÑúÎπÑÏä§ Îß§ÎãàÏ†Ä - API ÏßÑÏûÖÏ†ê (ÏôÑÏ†Ñ ÏàòÏ†ï)"""
    
    def __init__(self):
        self.logger = logging.getLogger(f"{__name__}.UnifiedStepServiceManager")
        self.implementation_manager = StepImplementationManager()
        self.status = ServiceStatus.INACTIVE
        self._lock = threading.RLock()
        
        # Ï†ÑÏ≤¥ Îß§ÎãàÏ†Ä Î©îÌä∏Î¶≠
        self.total_requests = 0
        self.successful_requests = 0
        self.failed_requests = 0
        self.start_time = datetime.now()
    
    async def initialize(self) -> bool:
        """Îß§ÎãàÏ†Ä Ï¥àÍ∏∞Ìôî"""
        try:
            with self._lock:
                self.status = ServiceStatus.INITIALIZING
                
                # Íµ¨ÌòÑÏ≤¥ Îß§ÎãàÏ†Ä Ï¥àÍ∏∞Ìôî Ï≤¥ÌÅ¨
                if self.implementation_manager:
                    self.status = ServiceStatus.ACTIVE
                    self.logger.info("‚úÖ UnifiedStepServiceManager Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
                    return True
                else:
                    self.status = ServiceStatus.ERROR
                    self.logger.error("‚ùå Íµ¨ÌòÑÏ≤¥ Îß§ÎãàÏ†Ä Ï¥àÍ∏∞Ìôî Ïã§Ìå®")
                    return False
                    
        except Exception as e:
            self.status = ServiceStatus.ERROR
            self.logger.error(f"‚ùå UnifiedStepServiceManager Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
            return False
    
    # ==============================================
    # üî• Í∏∞Ï°¥ API Ìò∏Ìôò Ìï®ÏàòÎì§ (100% Ïú†ÏßÄ) - delegation
    # ==============================================
    
    async def process_step_1_upload_validation(
        self,
        person_image: 'UploadFile',
        clothing_image: 'UploadFile',
        session_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """1Îã®Í≥Ñ: Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Í≤ÄÏ¶ù - ‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö Ïú†ÏßÄ"""
        inputs = {
            "person_image": person_image,
            "clothing_image": clothing_image,
            "session_id": session_id
        }
        result = await self.implementation_manager.execute_step(1, inputs)
        result.update({
            "step_name": "Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Í≤ÄÏ¶ù",
            "step_id": 1,
            "message": result.get("message", "Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Í≤ÄÏ¶ù ÏôÑÎ£å")
        })
        return result
    
    async def process_step_2_measurements_validation(
        self,
        measurements: Union[BodyMeasurements, Dict[str, Any]],
        session_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """2Îã®Í≥Ñ: Ïã†Ï≤¥ Ï∏°Ï†ïÍ∞í Í≤ÄÏ¶ù - ‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö Ïú†ÏßÄ"""
        inputs = {
            "measurements": measurements,
            "session_id": session_id
        }
        result = await self.implementation_manager.execute_step(2, inputs)
        result.update({
            "step_name": "Ïã†Ï≤¥ Ï∏°Ï†ïÍ∞í Í≤ÄÏ¶ù",
            "step_id": 2,
            "message": result.get("message", "Ïã†Ï≤¥ Ï∏°Ï†ïÍ∞í Í≤ÄÏ¶ù ÏôÑÎ£å")
        })
        return result
    
    async def process_step_3_human_parsing(
        self,
        session_id: str,
        enhance_quality: bool = True
    ) -> Dict[str, Any]:
        """3Îã®Í≥Ñ: Ïù∏Í∞Ñ ÌååÏã± - ‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö Ïú†ÏßÄ"""
        inputs = {
            "session_id": session_id,
            "enhance_quality": enhance_quality
        }
        result = await self.implementation_manager.execute_step(3, inputs)
        result.update({
            "step_name": "Ïù∏Í∞Ñ ÌååÏã±",
            "step_id": 3,
            "message": result.get("message", "Ïù∏Í∞Ñ ÌååÏã± ÏôÑÎ£å")
        })
        return result
    
    async def process_step_4_pose_estimation(
        self, 
        session_id: str, 
        detection_confidence: float = 0.5,
        clothing_type: str = "shirt"
    ) -> Dict[str, Any]:
        """4Îã®Í≥Ñ: Ìè¨Ï¶à Ï∂îÏ†ï Ï≤òÎ¶¨ - ‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö Ïú†ÏßÄ"""
        inputs = {
            "session_id": session_id,
            "detection_confidence": detection_confidence,
            "clothing_type": clothing_type
        }
        result = await self.implementation_manager.execute_step(4, inputs)
        result.update({
            "step_name": "Ìè¨Ï¶à Ï∂îÏ†ï",
            "step_id": 4,
            "message": result.get("message", "Ìè¨Ï¶à Ï∂îÏ†ï ÏôÑÎ£å")
        })
        return result
    
    async def process_step_5_clothing_analysis(
        self,
        session_id: str,
        analysis_detail: str = "medium",
        clothing_type: str = "shirt"
    ) -> Dict[str, Any]:
        """5Îã®Í≥Ñ: ÏùòÎ•ò Î∂ÑÏÑù Ï≤òÎ¶¨ - ‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö Ïú†ÏßÄ"""
        inputs = {
            "session_id": session_id,
            "analysis_detail": analysis_detail,
            "clothing_type": clothing_type,
            "quality_level": analysis_detail
        }
        result = await self.implementation_manager.execute_step(5, inputs)
        result.update({
            "step_name": "ÏùòÎ•ò Î∂ÑÏÑù",
            "step_id": 5,
            "message": result.get("message", "ÏùòÎ•ò Î∂ÑÏÑù ÏôÑÎ£å")
        })
        return result
    
    async def process_step_6_geometric_matching(
        self,
        session_id: str,
        matching_precision: str = "high"
    ) -> Dict[str, Any]:
        """6Îã®Í≥Ñ: Í∏∞ÌïòÌïôÏ†Å Îß§Ïπ≠ Ï≤òÎ¶¨ - ‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö Ïú†ÏßÄ"""
        inputs = {
            "session_id": session_id,
            "matching_precision": matching_precision
        }
        result = await self.implementation_manager.execute_step(6, inputs)
        result.update({
            "step_name": "Í∏∞ÌïòÌïôÏ†Å Îß§Ïπ≠",
            "step_id": 6,
            "message": result.get("message", "Í∏∞ÌïòÌïôÏ†Å Îß§Ïπ≠ ÏôÑÎ£å")
        })
        return result
    
    async def process_step_7_virtual_fitting(
        self,
        session_id: str,
        fitting_quality: str = "high"
    ) -> Dict[str, Any]:
        """7Îã®Í≥Ñ: Í∞ÄÏÉÅ ÌîºÌåÖ Ï≤òÎ¶¨ - ‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö Ïú†ÏßÄ"""
        inputs = {
            "session_id": session_id,
            "fitting_quality": fitting_quality
        }
        result = await self.implementation_manager.execute_step(8, inputs)  # VirtualFittingStep
        result.update({
            "step_name": "Í∞ÄÏÉÅ ÌîºÌåÖ",
            "step_id": 7,
            "message": result.get("message", "Í∞ÄÏÉÅ ÌîºÌåÖ ÏôÑÎ£å")
        })
        return result
    
    async def process_step_8_result_analysis(
        self,
        session_id: str,
        analysis_depth: str = "comprehensive"
    ) -> Dict[str, Any]:
        """8Îã®Í≥Ñ: Í≤∞Í≥º Î∂ÑÏÑù Ï≤òÎ¶¨ - ‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö Ïú†ÏßÄ"""
        inputs = {
            "session_id": session_id,
            "analysis_depth": analysis_depth
        }
        result = await self.implementation_manager.execute_step(10, inputs)  # QualityAssessmentStep
        result.update({
            "step_name": "Í≤∞Í≥º Î∂ÑÏÑù",
            "step_id": 8,
            "message": result.get("message", "Í≤∞Í≥º Î∂ÑÏÑù ÏôÑÎ£å")
        })
        return result
    
    # Ï∂îÍ∞Ä Step ÎåÄÏùë Î©îÏÑúÎìúÎì§
    async def process_step_5_cloth_warping(
        self,
        session_id: str,
        fabric_type: str = "cotton",
        clothing_type: str = "shirt"
    ) -> Dict[str, Any]:
        """Step 5: ÏùòÎ•ò ÏõåÌïë Ï≤òÎ¶¨"""
        inputs = {
            "session_id": session_id,
            "fabric_type": fabric_type,
            "clothing_type": clothing_type
        }
        result = await self.implementation_manager.execute_step(7, inputs)  # ClothWarpingStep
        result.update({
            "step_name": "ÏùòÎ•ò ÏõåÌïë",
            "step_id": 5,
            "message": result.get("message", "ÏùòÎ•ò ÏõåÌïë ÏôÑÎ£å")
        })
        return result
    
    async def process_step_7_post_processing(
        self,
        session_id: str,
        enhancement_level: str = "medium"
    ) -> Dict[str, Any]:
        """Step 7: ÌõÑÏ≤òÎ¶¨"""
        inputs = {
            "session_id": session_id,
            "enhancement_level": enhancement_level
        }
        result = await self.implementation_manager.execute_step(9, inputs)  # PostProcessingStep
        result.update({
            "step_name": "ÌõÑÏ≤òÎ¶¨",
            "step_id": 7,
            "message": result.get("message", "ÌõÑÏ≤òÎ¶¨ ÏôÑÎ£å")
        })
        return result
    
    # ÏôÑÏ†ÑÌïú ÌååÏù¥ÌîÑÎùºÏù∏ Ï≤òÎ¶¨
    async def process_complete_virtual_fitting(
        self,
        person_image: 'UploadFile',
        clothing_image: 'UploadFile',
        measurements: Union[BodyMeasurements, Dict[str, Any]],
        **kwargs
    ) -> Dict[str, Any]:
        """ÏôÑÏ†ÑÌïú Í∞ÄÏÉÅ ÌîºÌåÖ Ï≤òÎ¶¨ - ‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö Ïú†ÏßÄ"""
        inputs = {
            "person_image": person_image,
            "clothing_image": clothing_image,
            "measurements": measurements,
            **kwargs
        }
        return await self.implementation_manager.execute_step(0, inputs)
    
    # ==============================================
    # Í≥µÌÜµ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
    # ==============================================
    
    async def process_step(self, step_id: int, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """Step Ï≤òÎ¶¨ Í≥µÌÜµ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§"""
        try:
            with self._lock:
                self.total_requests += 1
            
            start_time = time.time()
            result = await self.implementation_manager.execute_step(step_id, inputs)
            processing_time = time.time() - start_time
            
            # Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
            with self._lock:
                if result.get("success", False):
                    self.successful_requests += 1
                else:
                    self.failed_requests += 1
            
            # Í≥µÌÜµ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
            result.update({
                "processing_time": processing_time,
                "interface_layer": True,
                "manager_status": self.status.value
            })
            
            return result
            
        except Exception as e:
            with self._lock:
                self.failed_requests += 1
            
            self.logger.error(f"‚ùå Step {step_id} Ï≤òÎ¶¨ Ïã§Ìå®: {e}")
            return {
                "success": False,
                "error": str(e),
                "step_id": step_id,
                "interface_layer": True,
                "manager_error": True,
                "timestamp": datetime.now().isoformat()
            }
    
    def get_all_metrics(self) -> Dict[str, Any]:
        """Î™®Îì† ÏÑúÎπÑÏä§ Î©îÌä∏Î¶≠ Î∞òÌôò"""
        with self._lock:
            return {
                "manager_status": self.status.value,
                "total_requests": self.total_requests,
                "successful_requests": self.successful_requests,
                "failed_requests": self.failed_requests,
                "success_rate": self.successful_requests / self.total_requests if self.total_requests > 0 else 0,
                "uptime_seconds": (datetime.now() - self.start_time).total_seconds(),
                "interface_layer": True,
                "architecture": "Interface-Implementation Pattern",
                "unified_step_mapping": True
            }
    
    async def cleanup_all(self):
        """Î™®Îì† ÏÑúÎπÑÏä§ Ï†ïÎ¶¨"""
        try:
            if self.implementation_manager:
                await self.implementation_manager.cleanup_all()
            
            with self._lock:
                self.status = ServiceStatus.INACTIVE
            
            self.logger.info("‚úÖ UnifiedStepServiceManager Ï†ïÎ¶¨ ÏôÑÎ£å")
        except Exception as e:
            self.logger.error(f"‚ùå UnifiedStepServiceManager Ï†ïÎ¶¨ Ïã§Ìå®: {e}")

# ==============================================
# üî• Ïã±Í∏ÄÌÜ§ Í¥ÄÎ¶¨Ïûê Ïù∏Ïä§ÌÑ¥Ïä§ (Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö 100% Ïú†ÏßÄ)
# ==============================================

_step_service_manager_instance: Optional[UnifiedStepServiceManager] = None
_manager_lock = threading.RLock()

def get_step_service_manager() -> UnifiedStepServiceManager:
    """UnifiedStepServiceManager Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò (ÎèôÍ∏∞ Î≤ÑÏ†Ñ)"""
    global _step_service_manager_instance
    
    with _manager_lock:
        if _step_service_manager_instance is None:
            _step_service_manager_instance = UnifiedStepServiceManager()
            logging.getLogger(__name__).info("‚úÖ UnifiedStepServiceManager Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± ÏôÑÎ£å")
    
    return _step_service_manager_instance

async def get_step_service_manager_async() -> UnifiedStepServiceManager:
    """UnifiedStepServiceManager Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò - ÎπÑÎèôÍ∏∞ Î≤ÑÏ†Ñ"""
    manager = get_step_service_manager()
    if manager.status == ServiceStatus.INACTIVE:
        await manager.initialize()
    return manager

def get_pipeline_manager_service() -> UnifiedStepServiceManager:
    """Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú Î≥ÑÏπ≠"""
    return get_step_service_manager()

async def get_pipeline_service() -> UnifiedStepServiceManager:
    """ÌååÏù¥ÌîÑÎùºÏù∏ ÏÑúÎπÑÏä§ Î∞òÌôò - ‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö Ïú†ÏßÄ"""
    return await get_step_service_manager_async()

def get_pipeline_service_sync() -> UnifiedStepServiceManager:
    """ÌååÏù¥ÌîÑÎùºÏù∏ ÏÑúÎπÑÏä§ Î∞òÌôò (ÎèôÍ∏∞) - ‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö Ïú†ÏßÄ"""
    return get_step_service_manager()

async def cleanup_step_service_manager():
    """StepServiceManager Ï†ïÎ¶¨"""
    global _step_service_manager_instance
    
    with _manager_lock:
        if _step_service_manager_instance:
            await _step_service_manager_instance.cleanup_all()
            _step_service_manager_instance = None
            logging.getLogger(__name__).info("üßπ UnifiedStepServiceManager Ï†ïÎ¶¨ ÏôÑÎ£å")

# ==============================================
# üî• Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
# ==============================================

def get_step_signature(step_id: int) -> Optional[UnifiedStepSignature]:
    """Step IDÎ°ú ÏãúÍ∑∏ÎãàÏ≤ò Ï°∞Ìöå"""
    return UNIFIED_STEP_MAPPING.get(step_id)

def get_ai_processing_steps() -> Dict[int, UnifiedStepSignature]:
    """AI Ï≤òÎ¶¨ Îã®Í≥ÑÎßå Î∞òÌôò"""
    return {
        step_id: signature 
        for step_id, signature in UNIFIED_STEP_MAPPING.items()
        if signature.step_type == StepType.AI_PROCESSING
    }

def validate_step_call(step_id: int, args: List[Any], kwargs: Dict[str, Any]) -> Dict[str, Any]:
    """Step Ìò∏Ï∂ú Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù"""
    signature = get_step_signature(step_id)
    if not signature:
        return {
            "valid": False,
            "error": f"Ïïå Ïàò ÏóÜÎäî Step ID: {step_id}"
        }
    
    # ÌïÑÏàò Ïù∏Ïûê Í∞úÏàò ÌôïÏù∏
    if len(args) != len(signature.required_args):
        return {
            "valid": False,
            "error": f"ÌïÑÏàò Ïù∏Ïûê Í∞úÏàò Î∂àÏùºÏπò. ÏòàÏÉÅ: {len(signature.required_args)}, Ïã§Ï†ú: {len(args)}"
        }
    
    # ÌïÑÏàò kwargs ÌôïÏù∏
    missing_kwargs = []
    for required_kwarg in signature.required_kwargs:
        if required_kwarg not in kwargs:
            missing_kwargs.append(required_kwarg)
    
    if missing_kwargs:
        return {
            "valid": False,
            "error": f"ÌïÑÏàò kwargs ÎàÑÎùΩ: {missing_kwargs}"
        }
    
    return {
        "valid": True,
        "signature_used": signature,
        "args_count": len(args),
        "kwargs_provided": list(kwargs.keys())
    }

# ==============================================
# üî• ÏÉÅÌÉú Î∞è Í∞ÄÏö©ÏÑ± Ï†ïÎ≥¥
# ==============================================

STEP_SERVICE_AVAILABLE = True
SERVICES_AVAILABLE = True

def get_service_availability_info() -> Dict[str, Any]:
    """ÏÑúÎπÑÏä§ Í∞ÄÏö©ÏÑ± Ï†ïÎ≥¥ Î∞òÌôò"""
    return {
        "step_service_available": STEP_SERVICE_AVAILABLE,
        "services_available": SERVICES_AVAILABLE,
        "architecture": "Interface-Implementation Pattern",
        "api_compatibility": "100%",
        "interface_layer": True,
        "implementation_delegation": True,
        "unified_step_mapping": True,
        "step_compatibility": {
            "step_01_human_parsing": True,
            "step_02_pose_estimation": True,
            "step_03_cloth_segmentation": True,
            "step_04_geometric_matching": True,
            "step_05_cloth_warping": True,
            "step_06_virtual_fitting": True,
            "step_07_post_processing": True,
            "step_08_quality_assessment": True,
            "all_steps_compatible": True
        }
    }

# ==============================================
# üî• Î™®Îìà Export (Í∏∞Ï°¥ Ïù¥Î¶Ñ 100% Ïú†ÏßÄ)
# ==============================================

__all__ = [
    # Î©îÏù∏ ÌÅ¥ÎûòÏä§Îì§
    "UnifiedStepServiceManager",
    "StepServiceInterface",
    "StepImplementationManager",
    
    # Ïã±Í∏ÄÌÜ§ Ìï®ÏàòÎì§ (Í∏∞Ï°¥ Ìò∏ÌôòÏÑ±)
    "get_step_service_manager",
    "get_step_service_manager_async",
    "get_pipeline_manager_service",
    "get_pipeline_service",
    "get_pipeline_service_sync",
    "cleanup_step_service_manager",
    
    # ÏÉÅÌÉú Í¥ÄÎ¶¨
    "ServiceStatus",
    "ServiceMetrics",
    "StepType",
    
    # Ïú†Ìã∏Î¶¨Ìã∞
    "get_service_availability_info",
    "get_step_signature",
    "get_ai_processing_steps",
    "validate_step_call",
    
    # Ïä§ÌÇ§Îßà
    "BodyMeasurements",
    
    # Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞
    "UnifiedStepSignature",
    "UNIFIED_STEP_MAPPING"
]

# Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú Î≥ÑÏπ≠
StepServiceManager = UnifiedStepServiceManager  # Í∏∞Ï°¥ Ïù¥Î¶Ñ Î≥ÑÏπ≠
PipelineManagerService = UnifiedStepServiceManager  # Í∏∞Ï°¥ Ïù¥Î¶Ñ Î≥ÑÏπ≠

# ==============================================
# üî• Î™®Îìà Î°úÎìú ÏôÑÎ£å Î©îÏãúÏßÄ
# ==============================================

logger = logging.getLogger(__name__)

logger.info("‚úÖ Step Service Interface Layer v15.0 Î°úÎìú ÏôÑÎ£å!")
logger.info("üéØ Interface-Implementation Pattern ÏôÑÏ†Ñ Ï†ÅÏö©")
logger.info("üîó API ÏßÑÏûÖÏ†ê Î∞è Í≥ÑÏïΩ Ï†ïÏùò ÏôÑÎ£å")
logger.info("‚úÖ Í∏∞Ï°¥ Ìï®ÏàòÎ™Ö 100% Ïú†ÏßÄ (API Ìò∏ÌôòÏÑ±)")
logger.info("üîß step_implementations.pyÎ°ú ÏúÑÏûÑ Î∞©Ïãù")
logger.info("‚ö° ÏàúÌôòÏ∞∏Ï°∞ ÏôÑÏ†Ñ Î∞©ÏßÄ (Îã®Î∞©Ìñ• ÏùòÏ°¥ÏÑ±)")
logger.info("üîÑ ÌÜµÌï© Step Îß§ÌïëÏúºÎ°ú ÏùºÍ¥ÄÏÑ± ÌôïÎ≥¥")
logger.info("üöÄ Ïã§Ï†ú Step ÌååÏùºÎì§Í≥º ÏôÑÎ≤Ω Ïó∞Îèô Ï§ÄÎπÑ")

logger.info(f"üìä ÏßÄÏõê Step:")
for step_id, signature in UNIFIED_STEP_MAPPING.items():
    logger.info(f"   Step {step_id:2d}: {signature.step_class_name} ‚Üí {signature.service_class_name}")

logger.info("üéØ Interface Layer Ï§ÄÎπÑ ÏôÑÎ£å - Implementation LayerÎ°ú ÏúÑÏûÑ!")