# backend/app/services/unified_step_mapping.py
"""
üî• MyCloset AI - ÌÜµÌï© Step Îß§Ìïë ÏÑ§Ï†ï v1.0
================================================================

‚úÖ Step Service ÏÑ∏ ÌååÏùºÏóêÏÑú Í≥µÌÜµÏúºÎ°ú ÏÇ¨Ïö©Ìï† ÌÜµÌï© Îß§Ìïë
‚úÖ BaseStepMixinÍ≥º ModelLoader ÏôÑÏ†Ñ Ìò∏Ìôò Îß§Ìïë
‚úÖ Ïã§Ï†ú Step ÌÅ¥ÎûòÏä§ÏôÄ Ï†ïÌôïÌïú ID Îß§Ìïë
‚úÖ Service ÌÅ¥ÎûòÏä§ÏôÄ Step ÌÅ¥ÎûòÏä§ ÏñëÎ∞©Ìñ• Îß§Ìïë
‚úÖ ÎèôÏ†Å ÏãúÍ∑∏ÎãàÏ≤òÏôÄ AI Î™®Îç∏ ÏöîÍµ¨ÏÇ¨Ìï≠
‚úÖ conda ÌôòÍ≤Ω Ïö∞ÏÑ† ÏµúÏ†ÅÌôî ÏÑ§Ï†ï

Author: MyCloset AI Team
Date: 2025-07-21
Version: 1.0 (Unified Mapping)
"""

import os
import sys
from typing import Dict, Any, Optional, List, Union, Tuple, Type
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path

# ==============================================
# üî• ÌÜµÌï© Step ID Îß§Ìïë (Ï†ïÌôïÌïú ÏàúÏÑú)
# ==============================================

# Ïã§Ï†ú Step ÌÅ¥ÎûòÏä§ Îß§Ìïë (Step 01-08)
UNIFIED_STEP_CLASS_MAPPING = {
    1: "HumanParsingStep",           # Step 01
    2: "PoseEstimationStep",         # Step 02  
    3: "ClothSegmentationStep",      # Step 03
    4: "GeometricMatchingStep",      # Step 04
    5: "ClothWarpingStep",           # Step 05
    6: "VirtualFittingStep",         # Step 06
    7: "PostProcessingStep",         # Step 07
    8: "QualityAssessmentStep",      # Step 08
}

# Service ÌÅ¥ÎûòÏä§ Îß§Ìïë (API Layer)
UNIFIED_SERVICE_CLASS_MAPPING = {
    1: "UploadValidationService",      # Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Í≤ÄÏ¶ù
    2: "MeasurementsValidationService", # Ïã†Ï≤¥ Ï∏°Ï†ï Í≤ÄÏ¶ù
    3: "HumanParsingService",          # Step 01 Ïó∞Îèô
    4: "PoseEstimationService",        # Step 02 Ïó∞Îèô
    5: "ClothingAnalysisService",      # Step 03 Ïó∞Îèô
    6: "GeometricMatchingService",     # Step 04 Ïó∞Îèô
    7: "ClothWarpingService",          # Step 05 Ïó∞Îèô
    8: "VirtualFittingService",        # Step 06 Ïó∞Îèô
    9: "PostProcessingService",        # Step 07 Ïó∞Îèô
    10: "ResultAnalysisService",       # Step 08 Ïó∞Îèô
    0: "CompletePipelineService",      # Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏
}

# Service ‚Üî Step ÏñëÎ∞©Ìñ• Îß§Ìïë
SERVICE_TO_STEP_MAPPING = {
    "HumanParsingService": "HumanParsingStep",
    "PoseEstimationService": "PoseEstimationStep", 
    "ClothingAnalysisService": "ClothSegmentationStep",
    "GeometricMatchingService": "GeometricMatchingStep",
    "ClothWarpingService": "ClothWarpingStep",
    "VirtualFittingService": "VirtualFittingStep",
    "PostProcessingService": "PostProcessingStep",
    "ResultAnalysisService": "QualityAssessmentStep",
}

STEP_TO_SERVICE_MAPPING = {v: k for k, v in SERVICE_TO_STEP_MAPPING.items()}

# Service ID ‚Üí Step ID Îß§Ìïë 
SERVICE_ID_TO_STEP_ID = {
    3: 1,   # HumanParsingService ‚Üí HumanParsingStep
    4: 2,   # PoseEstimationService ‚Üí PoseEstimationStep
    5: 3,   # ClothingAnalysisService ‚Üí ClothSegmentationStep
    6: 4,   # GeometricMatchingService ‚Üí GeometricMatchingStep
    7: 5,   # ClothWarpingService ‚Üí ClothWarpingStep
    8: 6,   # VirtualFittingService ‚Üí VirtualFittingStep
    9: 7,   # PostProcessingService ‚Üí PostProcessingStep
    10: 8,  # ResultAnalysisService ‚Üí QualityAssessmentStep
}

STEP_ID_TO_SERVICE_ID = {v: k for k, v in SERVICE_ID_TO_STEP_ID.items()}

# ==============================================
# üî• Ïã§Ï†ú AI Step ÏãúÍ∑∏ÎãàÏ≤ò (BaseStepMixin Ìò∏Ìôò)
# ==============================================

@dataclass
class UnifiedStepSignature:
    """ÌÜµÌï© Step ÏãúÍ∑∏ÎãàÏ≤ò"""
    step_class_name: str
    step_id: int
    service_id: int
    real_ai_required: bool = True
    required_args: List[str] = field(default_factory=list)
    required_kwargs: List[str] = field(default_factory=list)
    optional_kwargs: List[str] = field(default_factory=list)
    return_type: str = "Dict[str, Any]"
    ai_models_needed: List[str] = field(default_factory=list)
    description: str = ""
    basestepmixin_compatible: bool = True
    modelloader_required: bool = True

# Ïã§Ï†ú Step ÏãúÍ∑∏ÎãàÏ≤ò Îß§Ìïë (process() Î©îÏÑúÎìú Í∏∞Ï§Ä)
UNIFIED_STEP_SIGNATURES = {
    'HumanParsingStep': UnifiedStepSignature(
        step_class_name='HumanParsingStep',
        step_id=1,
        service_id=3,
        required_args=['person_image'],
        optional_kwargs=['enhance_quality', 'session_id'],
        ai_models_needed=['human_parsing_graphonomy', 'segmentation_model'],
        description='AI Í∏∞Î∞ò Ïù∏Í∞Ñ ÌååÏã± - ÏÇ¨Îûå Ïù¥ÎØ∏ÏßÄÏóêÏÑú Ïã†Ï≤¥ Î∂ÄÏúÑ Î∂ÑÌï†'
    ),
    'PoseEstimationStep': UnifiedStepSignature(
        step_class_name='PoseEstimationStep', 
        step_id=2,
        service_id=4,
        required_args=['image'],
        required_kwargs=['clothing_type'],
        optional_kwargs=['detection_confidence', 'session_id'],
        ai_models_needed=['pose_estimation_openpose', 'keypoint_detector'],
        description='AI Í∏∞Î∞ò Ìè¨Ï¶à Ï∂îÏ†ï - ÏÇ¨ÎûåÏùò Ìè¨Ï¶àÏôÄ Í¥ÄÏ†à ÏúÑÏπò Í≤ÄÏ∂ú'
    ),
    'ClothSegmentationStep': UnifiedStepSignature(
        step_class_name='ClothSegmentationStep',
        step_id=3,
        service_id=5,
        required_args=['image'],
        required_kwargs=['clothing_type', 'quality_level'],
        optional_kwargs=['session_id'],
        ai_models_needed=['u2net_cloth_seg', 'texture_analyzer'],
        description='AI Í∏∞Î∞ò ÏùòÎ•ò Î∂ÑÌï† - ÏùòÎ•ò Ïù¥ÎØ∏ÏßÄÏóêÏÑú ÏùòÎ•ò ÏòÅÏó≠ Î∂ÑÌï†'
    ),
    'GeometricMatchingStep': UnifiedStepSignature(
        step_class_name='GeometricMatchingStep',
        step_id=4,
        service_id=6,
        required_args=['person_image', 'clothing_image'],
        optional_kwargs=['pose_keypoints', 'body_mask', 'clothing_mask', 'matching_precision', 'session_id'],
        ai_models_needed=['geometric_matching_gmm', 'tps_network', 'feature_extractor'],
        description='AI Í∏∞Î∞ò Í∏∞ÌïòÌïôÏ†Å Îß§Ïπ≠ - ÏÇ¨ÎûåÍ≥º ÏùòÎ•ò Í∞ÑÏùò AI Îß§Ïπ≠'
    ),
    'ClothWarpingStep': UnifiedStepSignature(
        step_class_name='ClothWarpingStep',
        step_id=5,
        service_id=7,
        required_args=['cloth_image', 'person_image'],
        optional_kwargs=['cloth_mask', 'fabric_type', 'clothing_type', 'session_id'],
        ai_models_needed=['cloth_warping_net', 'deformation_network'],
        description='AI Í∏∞Î∞ò ÏùòÎ•ò ÏõåÌïë - AIÎ°ú ÏùòÎ•òÎ•º ÏÇ¨Îûå Ï≤¥ÌòïÏóê ÎßûÍ≤å Î≥ÄÌòï'
    ),
    'VirtualFittingStep': UnifiedStepSignature(
        step_class_name='VirtualFittingStep',
        step_id=6,
        service_id=8,
        required_args=['person_image', 'cloth_image'],
        optional_kwargs=['pose_data', 'cloth_mask', 'fitting_quality', 'session_id'],
        ai_models_needed=['ootdiffusion', 'rendering_network', 'style_transfer_model'],
        description='AI Í∏∞Î∞ò Í∞ÄÏÉÅ ÌîºÌåÖ - AIÎ°ú ÏÇ¨ÎûåÏóêÍ≤å ÏùòÎ•òÎ•º Í∞ÄÏÉÅÏúºÎ°ú Ï∞©Ïö©'
    ),
    'PostProcessingStep': UnifiedStepSignature(
        step_class_name='PostProcessingStep',
        step_id=7,
        service_id=9,
        required_args=['fitted_image'],
        optional_kwargs=['enhancement_level', 'session_id'],
        ai_models_needed=['srresnet_x4', 'enhancement_network'],
        description='AI Í∏∞Î∞ò ÌõÑÏ≤òÎ¶¨ - AIÎ°ú ÌîºÌåÖ Í≤∞Í≥º Ïù¥ÎØ∏ÏßÄ ÌíàÏßà Ìñ•ÏÉÅ'
    ),
    'QualityAssessmentStep': UnifiedStepSignature(
        step_class_name='QualityAssessmentStep',
        step_id=8,
        service_id=10,
        required_args=['final_image'],
        optional_kwargs=['analysis_depth', 'session_id'],
        ai_models_needed=['quality_assessment_clip', 'evaluation_network'],
        description='AI Í∏∞Î∞ò ÌíàÏßà ÌèâÍ∞Ä - AIÎ°ú ÏµúÏ¢Ö Í≤∞Í≥ºÏùò ÌíàÏßà Ï†êÏàò Î∞è Î∂ÑÏÑù'
    )
}

# ==============================================
# üî• Step Factory Helper (BaseStepMixin Ìò∏Ìôò)
# ==============================================

class StepFactoryHelper:
    """Ïã§Ï†ú Step ÌÅ¥ÎûòÏä§ ÏÉùÏÑ± ÎèÑÏö∞ÎØ∏ (BaseStepMixin Ìò∏Ìôò)"""
    
    @staticmethod
    def get_step_class_by_id(step_id: int) -> Optional[str]:
        """Step IDÎ°ú ÌÅ¥ÎûòÏä§Î™Ö Ï°∞Ìöå"""
        return UNIFIED_STEP_CLASS_MAPPING.get(step_id)
    
    @staticmethod
    def get_service_class_by_id(service_id: int) -> Optional[str]:
        """Service IDÎ°ú ÌÅ¥ÎûòÏä§Î™Ö Ï°∞Ìöå"""
        return UNIFIED_SERVICE_CLASS_MAPPING.get(service_id)
    
    @staticmethod
    def get_step_signature(step_class_name: str) -> Optional[UnifiedStepSignature]:
        """Step ÌÅ¥ÎûòÏä§Î™ÖÏúºÎ°ú ÏãúÍ∑∏ÎãàÏ≤ò Ï°∞Ìöå"""
        return UNIFIED_STEP_SIGNATURES.get(step_class_name)
    
    @staticmethod
    def get_step_import_path(step_id: int) -> Optional[Tuple[str, str]]:
        """Step IDÎ°ú import Í≤ΩÎ°ú Î∞òÌôò"""
        import_mapping = {
            1: ("..ai_pipeline.steps.step_01_human_parsing", "HumanParsingStep"),
            2: ("..ai_pipeline.steps.step_02_pose_estimation", "PoseEstimationStep"),
            3: ("..ai_pipeline.steps.step_03_cloth_segmentation", "ClothSegmentationStep"),
            4: ("..ai_pipeline.steps.step_04_geometric_matching", "GeometricMatchingStep"),
            5: ("..ai_pipeline.steps.step_05_cloth_warping", "ClothWarpingStep"),
            6: ("..ai_pipeline.steps.step_06_virtual_fitting", "VirtualFittingStep"),
            7: ("..ai_pipeline.steps.step_07_post_processing", "PostProcessingStep"),
            8: ("..ai_pipeline.steps.step_08_quality_assessment", "QualityAssessmentStep"),
        }
        return import_mapping.get(step_id)
    
    @staticmethod
    def create_basestepmixin_config(step_id: int, **kwargs) -> Dict[str, Any]:
        """BaseStepMixin Ìò∏Ìôò ÏÑ§Ï†ï ÏÉùÏÑ±"""
        step_class_name = UNIFIED_STEP_CLASS_MAPPING.get(step_id)
        signature = UNIFIED_STEP_SIGNATURES.get(step_class_name)
        
        base_config = {
            'device': kwargs.get('device', 'mps' if kwargs.get('is_m3_max', False) else 'cpu'),
            'optimization_enabled': True,
            'memory_gb': 128.0 if kwargs.get('is_m3_max', False) else 16.0,
            'is_m3_max': kwargs.get('is_m3_max', False),
            'use_fp16': kwargs.get('use_fp16', True),
            'auto_warmup': kwargs.get('auto_warmup', True),
            'auto_memory_cleanup': kwargs.get('auto_memory_cleanup', True),
            'model_loader': kwargs.get('model_loader'),
            'di_container': kwargs.get('di_container'),
            'step_name': step_class_name,
            'step_id': step_id,
            'real_ai_mode': True,
            'basestepmixin_compatible': True,
            'modelloader_required': True,
            'disable_fallback': True,
            **kwargs
        }
        
        if signature:
            base_config.update({
                'ai_models_needed': signature.ai_models_needed,
                'required_args': signature.required_args,
                'required_kwargs': signature.required_kwargs,
                'optional_kwargs': signature.optional_kwargs
            })
        
        return base_config

# ==============================================
# üî• conda ÌôòÍ≤Ω Ïö∞ÏÑ† ÏµúÏ†ÅÌôî
# ==============================================

def setup_conda_optimization():
    """conda ÌôòÍ≤Ω Ïö∞ÏÑ† ÏµúÏ†ÅÌôî ÏÑ§Ï†ï"""
    try:
        # conda ÌôòÍ≤Ω Í∞êÏßÄ
        conda_env = os.environ.get('CONDA_DEFAULT_ENV')
        if conda_env:
            print(f"üêç conda ÌôòÍ≤Ω Í∞êÏßÄ: {conda_env}")
            
            # PyTorch conda ÏµúÏ†ÅÌôî
            try:
                import torch
                # condaÏóêÏÑú ÏÑ§ÏπòÎêú PyTorch ÏµúÏ†ÅÌôî
                if hasattr(torch.backends, 'mps') and torch.backends.mps.is_available():
                    torch.backends.mps.empty_cache()
                    print("üçé M3 Max MPS ÏµúÏ†ÅÌôî ÌôúÏÑ±Ìôî")
                
                # CPU Ïä§Î†àÎìú ÏµúÏ†ÅÌôî (conda ÌôòÍ≤Ω Ïö∞ÏÑ†)
                cpu_count = os.cpu_count()
                torch.set_num_threads(max(1, cpu_count // 2))
                print(f"üßµ PyTorch Ïä§Î†àÎìú ÏµúÏ†ÅÌôî: {torch.get_num_threads()}/{cpu_count}")
                
            except ImportError:
                pass
            
            # conda ÌôòÍ≤Ω Î≥ÄÏàò ÏÑ§Ï†ï
            os.environ['OMP_NUM_THREADS'] = str(max(1, os.cpu_count() // 2))
            os.environ['MKL_NUM_THREADS'] = str(max(1, os.cpu_count() // 2))
            
            return True
            
    except Exception as e:
        print(f"‚ö†Ô∏è conda ÏµúÏ†ÅÌôî ÏÑ§Ï†ï Ïã§Ìå®: {e}")
        return False

# ==============================================
# üî• Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
# ==============================================

def get_step_id_by_service_id(service_id: int) -> Optional[int]:
    """Service IDÎ°ú Step ID Ï°∞Ìöå"""
    return SERVICE_ID_TO_STEP_ID.get(service_id)

def get_service_id_by_step_id(step_id: int) -> Optional[int]:
    """Step IDÎ°ú Service ID Ï°∞Ìöå"""
    return STEP_ID_TO_SERVICE_ID.get(step_id)

def validate_step_compatibility(step_class_name: str) -> Dict[str, Any]:
    """Step Ìò∏ÌôòÏÑ± Í≤ÄÏ¶ù"""
    signature = UNIFIED_STEP_SIGNATURES.get(step_class_name)
    if not signature:
        return {
            "compatible": False,
            "error": f"Step {step_class_name} ÏãúÍ∑∏ÎãàÏ≤òÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå"
        }
    
    return {
        "compatible": True,
        "basestepmixin_compatible": signature.basestepmixin_compatible,
        "modelloader_required": signature.modelloader_required,
        "ai_models_needed": signature.ai_models_needed,
        "step_id": signature.step_id,
        "service_id": signature.service_id
    }

def get_all_available_steps() -> List[int]:
    """ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™®Îì† Step ID Î∞òÌôò"""
    return list(UNIFIED_STEP_CLASS_MAPPING.keys())

def get_all_available_services() -> List[int]:
    """ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™®Îì† Service ID Î∞òÌôò"""
    return list(UNIFIED_SERVICE_CLASS_MAPPING.keys())

def get_system_compatibility_info() -> Dict[str, Any]:
    """ÏãúÏä§ÌÖú Ìò∏ÌôòÏÑ± Ï†ïÎ≥¥"""
    return {
        "total_steps": len(UNIFIED_STEP_CLASS_MAPPING),
        "total_services": len(UNIFIED_SERVICE_CLASS_MAPPING),
        "basestepmixin_compatible_steps": len([
            s for s in UNIFIED_STEP_SIGNATURES.values() 
            if s.basestepmixin_compatible
        ]),
        "modelloader_required_steps": len([
            s for s in UNIFIED_STEP_SIGNATURES.values() 
            if s.modelloader_required
        ]),
        "conda_optimized": 'CONDA_DEFAULT_ENV' in os.environ,
        "step_service_mapping": SERVICE_TO_STEP_MAPPING,
        "step_signatures_available": list(UNIFIED_STEP_SIGNATURES.keys())
    }

# ==============================================
# üî• Î™®Îìà export
# ==============================================

__all__ = [
    # Îß§Ìïë ÎîïÏÖîÎÑàÎ¶¨Îì§
    "UNIFIED_STEP_CLASS_MAPPING",
    "UNIFIED_SERVICE_CLASS_MAPPING", 
    "SERVICE_TO_STEP_MAPPING",
    "STEP_TO_SERVICE_MAPPING",
    "SERVICE_ID_TO_STEP_ID",
    "STEP_ID_TO_SERVICE_ID",
    
    # ÏãúÍ∑∏ÎãàÏ≤ò Î∞è Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§
    "UnifiedStepSignature",
    "UNIFIED_STEP_SIGNATURES",
    
    # Ìó¨Ìçº ÌÅ¥ÎûòÏä§ Î∞è Ìï®Ïàò
    "StepFactoryHelper",
    "setup_conda_optimization",
    "get_step_id_by_service_id",
    "get_service_id_by_step_id",
    "validate_step_compatibility",
    "get_all_available_steps",
    "get_all_available_services",
    "get_system_compatibility_info"
]

# Ï¥àÍ∏∞Ìôî Ïãú conda ÏµúÏ†ÅÌôî Ïã§Ìñâ
if __name__ != "__main__":
    setup_conda_optimization()

print("‚úÖ ÌÜµÌï© Step Îß§Ìïë ÏÑ§Ï†ï Î°úÎìú ÏôÑÎ£å!")
print(f"üìä Step ÌÅ¥ÎûòÏä§: {len(UNIFIED_STEP_CLASS_MAPPING)}Í∞ú")
print(f"üìä Service ÌÅ¥ÎûòÏä§: {len(UNIFIED_SERVICE_CLASS_MAPPING)}Í∞ú") 
print(f"üîó BaseStepMixin Ìò∏Ìôò: 100%")
print(f"üîó ModelLoader Ïó∞Îèô: 100%")
print(f"üêç conda ÌôòÍ≤Ω ÏµúÏ†ÅÌôî: {'‚úÖ' if 'CONDA_DEFAULT_ENV' in os.environ else '‚ùå'}")